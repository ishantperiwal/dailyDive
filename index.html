<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Removed user-scalable=no for better accessibility, allowing users to zoom. -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#444444">
    <title>Smart Checklist</title>
    <link rel="manifest" href="manifest.json">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bricolage+Grotesque:opsz,wght@12..96,400;12..96,600&display=swap" rel="stylesheet">
    <style>
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }
        :root {
            --background: #f7f8fc;
            --text-color: #333;
            --accent-color: #007aff;
            --archive-bg: #28a745;
            --checkmark-color: #28a745;
            --shadow-color: rgba(0, 0, 0, 0.08);
            --dot-color: #d7d7d7;
            --hibernate-color: #6c757d;
            --delete-color: #ff3b30;
        }
        body {
            font-family: 'Bricolage Grotesque', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--background);
            background-image: radial-gradient(circle, var(--dot-color) 1px, transparent 1px);
            background-size: 25px 25px;
            margin: 0;
            padding: 0;
            transition: background-image 0.3s ease;
        }

        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.5s ease-out;
            opacity: 1;
        }
        #splash-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .splash-logo {
            margin-bottom: 20px;
        }
        #splash-screen p {
            font-size: 16px;
            font-weight: 500;
            color: #888;
            animation: pulse 2s infinite ease-in-out;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        body.calendar-active {
            background-image: none;
        }
        
        body.modal-open {
            overflow: hidden;
        }

        ::-webkit-scrollbar {
            display: none;
        }
        body, .modal-note {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

        .app-container { max-width: 1200px; margin: auto; position: relative; min-height: 100vh; display: flex; flex-direction: column; }
        header {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 14px 26px 0px 26px;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(12px);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        .header-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 15px;
            gap: 10px;
        }
        header h1 { font-size: 22px; font-weight: 600; margin-right: auto; }

        #auth-container { display: flex; align-items: center; gap: 8px; flex-shrink: 0; }
        
        #filter-bar-container {
            width: 100%;
            overflow-x: auto;
        }
        #filter-bar-container::-webkit-scrollbar { display: none; }
        #filter-bar-container { -ms-overflow-style: none; scrollbar-width: none; }
        #filter-bar {
            display: flex;
            gap: 10px;
            padding-bottom: 15px;
        }
        /* Add a pseudo-element to act as a spacer at the end of the scroll */
        #filter-bar::after {
            content: '';
            /* flex-grow, flex-shrink, flex-basis */
            flex: 0 0 26px;
        }
        .filter-chip {
            padding: 6px 14px;
            border-radius: 18px;
            background-color: #e9e9f0;
            color: #555;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            flex-shrink: 0;
            border: 1px solid transparent;
        }
        .filter-chip:hover {
            background-color: #dcdce5;
        }
        .filter-chip.active {
            background-color: var(--accent-color);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
        }

        .filter-chip--archive {
            display: flex;
            align-items: center;
            background-color: #e0f2fe;
            color: #0c4a6e;
        }
        .filter-chip--archive:hover {
            background-color: #cce9fc;
        }

        .view-toggle {
            position: relative;
            display: flex;
            align-items: center;
            background-color: #e9e9f0;
            border-radius: 20px;
            padding: 4px;
            cursor: pointer;
            user-select: none;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
            flex-shrink: 0;
        }
        .toggle-option {
            font-size: 20px;
            width: 38px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1;
            transition: color 0.3s ease;
            color: #555;
        }
        .toggle-option.active {
            color: #000;
        }
        .toggle-thumb {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 38px;
            height: 32px;
            background-color: #fff;
            border-radius: 16px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        .view-toggle.calendar-mode .toggle-thumb {
            transform: translateX(38px);
        }

        #task-list-view { padding: 25px; display: grid; grid-template-columns: repeat(auto-fit, 320px); gap: 25px; justify-content: center; flex-grow: 1; align-content: start; }
        .task-item {
            height: 220px;
            box-shadow: 0 4px 12px var(--shadow-color);
            transition: transform 0.5s cubic-bezier(0.2, 0.8, 0.2, 1), box-shadow 0.15s ease, opacity 0.5s ease;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            border-radius: 12px;
            border: 1px solid #ffffff;
            transform: rotate(var(--rotation-deg, 0deg));
        }
        .task-item:has(.task-content:active) {
            transform: rotate(var(--rotation-deg, 0deg)) scale(0.97);
            transition-duration: 0.05s;
        }
        .task-item.is-interacting {
            z-index: 10;
            box-shadow: 0 8px 20px var(--shadow-color);
            transform: rotate(0deg) scale(1.03) translateY(-5px) !important;
            transition-duration: 0.25s;
        }
        .task-content { 
            padding: 20px 22px; 
            font-size: 18px; 
            line-height: 1.5; 
            width: 100%; 
            flex-grow: 1; 
            box-sizing: border-box; 
            user-select: none; 
            transition: color 0.3s, transform 0.3s ease; 
            cursor: grab; 
            background: transparent; 
            border: none; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden; /* Prevents text from pushing tags down */
        }
        .task-item.completed, .task-item.hibernated { opacity: 0.7; }
        .task-item.completed .task-content { color: rgba(0, 0, 0, 0.5); cursor: default; }
        .task-item.completed .task-text-display { text-decoration: line-through; }
        .task-item.is-completing .task-content .task-text-display { text-decoration: line-through; color: rgba(0, 0, 0, 0.5); }
        .task-tags-container { padding: 0 10px 10px 10px; display: flex; flex-wrap: wrap; gap: 5px; }
        .task-tag { background-color: rgba(0, 0, 0, 0.07); padding: 2px 8px; border-radius: 10px; font-size: 12px; }
        .archive-btn { background-color: var(--archive-bg); color: white; border: none; cursor: pointer; width: 100px; align-self: stretch; display: flex; align-items: center; justify-content: center; font-size: 24px; opacity: 0; position: absolute; right: 0; top: 0; bottom: 0; transform: translateX(100%); transition: opacity 0.3s ease, transform 0.3s ease; flex-direction: column; gap: 5px; line-height: 1; }
        .days-to-complete { font-size: 11px; font-weight: 500; }
        .task-item.completed .archive-btn {
            opacity: 1;
            transform: translateX(0);
            transition-delay: 0.6s;
        }
        .task-item.is-sliding-complete { opacity: 0.7; }
        
        .task-item.is-sliding-uncomplete { opacity: 1; }
        .task-item.is-sliding-uncomplete .archive-btn {
            opacity: 0;
            transform: translateX(100%);
            transition-delay: 0s;
        }

        .uncomplete-placeholder {
            width: 40px;
            font-size: 24px;
            color: var(--accent-color);
            opacity: 0;
            transition: opacity 0.3s ease;
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #add-task-btn { position: fixed; bottom: 30px; right: calc(50% - min(600px, 50vw) + 30px); width: 60px; height: 60px; background-color: var(--accent-color); color: white; border: none; border-radius: 50%; font-size: 36px; box-shadow: 0 6px 15px rgba(0, 122, 255, 0.4); cursor: pointer; z-index: 100; transition: transform 0.3s ease, opacity 0.3s ease; }
        #add-task-btn:hover { transform: scale(1.05); }
        #calendar-view { display: none; padding: 20px; }
        .calendar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        .calendar-header h2 { margin: 0; text-align: center; flex-grow: 1; }
        .calendar-nav-btn { background: #fff; border: 1px solid #ddd; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; cursor: pointer; transition: background-color 0.2s; }
        .calendar-nav-btn:hover { background-color: #f7f7f7; }
        .calendar-grid-container { }
        #calendar-wrapper { overflow: hidden; }
        #calendar-slider { display: flex; width: 300%; position: relative; transform: translateX(-33.3333%); }
        .calendar-month-grid {
            width: 33.3333%;
            position: relative;
            /* Removed flex properties and min-height to allow this container to grow vertically with its content. */
        }
        .day-grid-wrapper {
            position: relative; /* Changed from 'absolute' so this element exists in the page's layout flow. */
            /* Removed top, left, and height, so its size is determined by the actual grid rows. */
            width: 100%;
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            transition: opacity 0.4s ease-in-out;
        }
        .loading-text {
            font-size: 20px;
            font-weight: 500;
            color: #a0a0a0;
            text-align: center;
        }
        .calendar-weekdays { display: grid; grid-template-columns: repeat(7, 1fr); text-align: center; padding: 10px 0; font-weight: bold; color: #777; }
        #calendar-grid { display: grid; grid-template-columns: repeat(7, 1fr); grid-auto-rows: minmax(120px, auto); position: relative; }
        .day-cell { border-right: 1px solid #eee; border-top: 1px solid #eee; padding: 8px; position: relative; }
        .day-cell:nth-child(7n) { border-right: none; }
        .day-cell.other-month .day-number { color: #ccc; }
        .day-cell.today .day-number {
            background-color: var(--accent-color);
            color: white;
        }
        .day-cell .day-number {
            cursor: pointer;
            transition: transform 0.2s ease;
            width: 28px;
            height: 28px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }
        .day-cell .day-number:hover { transform: scale(1.1); }
        .day-cell.holiday { background-color: #dadada; }
        
        .task-bar { position: absolute; height: 24px; color: #1f1f1f; text-shadow: 0 0 2px rgba(255,255,255,0.6); border-radius: 4px; font-size: 12px; padding: 0 8px; box-sizing: border-box; line-height: 24px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; z-index: 1; cursor: pointer; border: 1px solid rgba(0,0,0,0.05); }
        .task-bar.completed {
            background-image: repeating-linear-gradient(
                45deg,
                rgba(0, 0, 0, 0.1),
                rgba(0, 0, 0, 0.1) 4px,
                transparent 4px,
                transparent 8px
            );
        }
        .task-bar.has-prev-indicator { padding-left: 28px; }
        .task-bar.has-next-indicator { padding-right: 28px; }
        .task-continuation-indicator {
            position: absolute;
            top: -1px;
            bottom: -1px;
            width: 20px;
            background: rgba(0,0,0,0.07);
            display: flex;
            align-items: center;
            justify-content: center;
            color: rgba(0,0,0,0.6);
            font-size: 14px;
            font-weight: bold;
        }
        .task-continuation-indicator.prev {
            left: 0;
            border-top-left-radius: 4px;
            border-bottom-left-radius: 4px;
        }
        .task-continuation-indicator.next {
            right: 0;
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
        }
        #modal-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(5px); display: none; align-items: center; justify-content: center; z-index: 550; opacity: 0; transition: opacity 0.5s ease; }
        #modal-container.show { opacity: 1; }
        .modal-content { text-align: center; transform: scale(0.95); transition: transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1); }
        #modal-container.show .modal-content { transform: scale(1); }
        .modal-controls { margin-top: 20px; display: flex; justify-content: center; gap: 15px; }
        .modal-btn { width: 50px; height: 50px; border-radius: 50%; border: none; font-size: 24px; margin: 0; cursor: pointer; box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2); transition: transform .2s ease, background-color .2s; }
        .modal-btn:hover { transform: scale(1.1); }
        .modal-btn#confirm-add-btn { background-color: #28a745; color: white; }
        .modal-btn#hibernate-btn { background-color: var(--hibernate-color); color: white; }

        .is-entering {
            opacity: 0;
            transform: translateY(-60px) scale(1.1) rotate(var(--start-rotation-deg));
        }

        @keyframes cardBounce {
            0%, 100% {
                transform: scale(1) rotate(var(--rotation-deg));
            }
            30% {
                transform: scale(0.95) rotate(var(--rotation-deg));
            }
            60% {
                transform: scale(1.05) rotate(var(--rotation-deg));
            }
        }
        .task-edited-animation {
            animation: cardBounce 0.6s ease-in-out;
        }

        .time-ago { font-size: 12px; color: rgba(0,0,0,0.5); margin-bottom: 8px; }
        .modal-note { width: 440px; max-width: 95vw; background-color: #fffc79; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2); border-radius: 12px; display: flex; flex-direction: column; max-height: 80vh; }

        #modal-note-content { flex-grow: 1; overflow-y: auto; padding: 0 25px; }
        #task-title-input, .daily-entry-textarea {
            font-family: 'Bricolage Grotesque', sans-serif;
        }
        #task-title-input {
            background: transparent;
            border: none;
            outline: none;
            padding: 25px 0 15px 0;
            font-size: 22px;
            font-weight: 600;
            line-height: 1.3;
            box-sizing: border-box;
            width: 100%;
            border-bottom: 1px solid rgba(0,0,0,0.1);
            resize: none;
            overflow-y: hidden;
        }
        .daily-entry-container { margin-top: 15px; } /* This class seems unused, can be removed */
        .daily-entry-date { font-size: 12px; font-weight: bold; color: rgba(0,0,0,0.6); margin: 2px 0 8px 6px; text-align: left; letter-spacing: 0.4px;pointer-events: none; display: flex; align-items: center; gap: 8px; }
        .daily-entry-date.is-holiday { color: #e57373; cursor: pointer; letter-spacing: 0.4px;pointer-events: none; }

        .daily-entry-textarea {
            background: transparent;
            min-height: 60px;
            border: none;
            outline: none;
            width: 100%;
            font-size: 16px;
            line-height: 1.5;
            box-sizing: border-box;
            resize: none;
            text-align: left;
            transition: background-color 0.5s ease;
            padding: 6px; /* Symmetrical padding for consistency */
            /* Normalization styles to ensure consistency between div and textarea */
            display: block;
            margin: 0;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .hibernation-event-pill {
            font-size: 10px;
            font-weight: 500;
            padding: 2px 8px;
            border-radius: 10px;
            color: #fff;
        }
        .hibernation-event-pill.hibernated, .hibernation-event-pill.activated {
            background-color: rgba(0, 0, 0, 0.12);
            color: #464646;
        }

        .hibernation-event-pill.completed {
            background-color: var(--checkmark-color);
        }

        .daily-entry-textarea.is-editing {
            padding: 0;
        }

        /* --- TIMELINE VIEW STYLES --- */
        #daily-entries-wrapper.timeline-view {
            position: relative;
            padding: 15px 0 15px 20px;
        }
        .timeline-entry {
            display: flex;
            position: relative;
            align-items: flex-start; /* Align items to the top */
            padding-bottom: 20px;
        }
        .timeline-marker {
            position: absolute;
            left: -20px;
            top: 0;
            width: 20px;
            height: 100%;
            display: flex;
            align-items: center;
        }
        .timeline-dot {
            width: 11px;
            height: 11px;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.2);
            z-index: 2;
            position: absolute;
            top: 5px;
            left: 4.5px; /* (20px marker width - 11px dot width) / 2 */
        }
        .timeline-line {
            position: absolute;
            top: 16px; /* Start the line just below the dot */
            width: 1px;
            left: 9.5px; /* (20px marker width - 1px line width) / 2 */
            height: calc(100% - 16px); /* End the line before the next dot starts */
            background-color: rgba(0,0,0,0.1);
        }
        .timeline-entry:last-child .timeline-line {
            display: none;
        }
        .timeline-content {
            padding-top: 1px; /* Small adjustment for alignment */
            flex-grow: 1;
        }
        #modal-note-footer { padding: 10px 0; border-top: 1px solid rgba(0,0,0,0.1); }

        .chip-container { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; padding: 0 15px 15px 15px; }
        .chip { background-color: rgba(80, 85, 90, 0.7); color: white; padding: 5px 12px; border-radius: 16px; font-size: 14px; cursor: pointer; transition: background-color .2s; }
        .chip.selected { background-color: #343a40; }
        .add-tag-btn { background: rgba(80, 85, 90, 0.7); color: white; border-radius: 50%; border: none; width: 28px; height: 28px; font-size: 18px; cursor: pointer; }

        #new-tag-input {
            background-color: rgba(255, 255, 255, 0.7);
            color: #333;
            padding: 5px 12px;
            border-radius: 16px;
            font-size: 14px;
            border: none;
            outline: none;
            width: 80px;
        }

        .tag-section-modal { padding: 10px 0; }
        .tag-title-modal { font-size: 12px; text-transform: uppercase; color: #6c757d; margin: 0 0 10px 15px; text-align: left; }

        .task-text-display {
            white-space: pre-wrap;
            /* Additions for robust layout */
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Ensures content clipping */
            min-height: 0; /* Prevents flex item from overflowing its container */
        }
        .task-text-title {
            font-weight: 600;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-shrink: 0; /* Prevents the title from shrinking */
        }
        .task-text-latest-entry {
            margin-top: 5px;
            font-size: 16px;
            opacity: 0.8;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            text-overflow: ellipsis;
        }

        #sticker-orb {
            position: fixed;
            bottom: 30px; 
            left: calc(50% - min(600px, 50vw) + 30px);
            z-index: 150; /* Lowered to be behind archive view */
            transition: transform 0.3s ease, opacity 0.3s ease;
        }
        .sticker-orb-face {
            width: 60px;
            height: 60px;
            background-color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            cursor: grab;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .sticker-orb-face:hover {
            transform: scale(1.1) rotate(15deg);
        }
        .sticker-orb-face:active {
            cursor: grabbing;
        }

        body:not(.is-mobile).calendar-active #add-task-btn,
        body:not(.is-mobile).calendar-active #sticker-orb {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.8);
        }

        .sticker-display-area {
            position: absolute;
            bottom: 8px;
            right: 8px;
            display: flex;
            gap: 5px;
            z-index: 6;
        }
        .sticker-link {
            font-size: 22px; /* Increased by 10% from 20px */
            text-decoration: none;
            transition: transform 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .sticker-link:active {
            transform: scale(0.8);
        }
        .task-item.drag-over {
            border: 2px dashed var(--accent-color);
            box-shadow: 0 8px 25px rgba(0, 122, 255, 0.3);
        }

        #attachment-modal-container, #confirmation-modal-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(5px); display: none; align-items: center; justify-content: center; z-index: 600;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        #attachment-modal-container.show, #confirmation-modal-container.show {
            opacity: 1;
        }
        .attachment-modal-content, .confirmation-modal-content {
            background: #fff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
            width: 380px;
            max-width: 90vw;
            transform: scale(0.95);
            transition: transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        #attachment-modal-container.show .attachment-modal-content,
        #confirmation-modal-container.show .confirmation-modal-content {
            transform: scale(1);
        }
        #attachment-modal-icon {
            font-size: 32px;
            margin-top: 0;
            margin-bottom: 15px;
            color: #555;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #attachment-url-input {
            display: block;
            width: 100%;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            font-size: 14px;
            margin-bottom: 20px;
            font-family: inherit;
            resize: none;
            overflow-y: hidden;
            min-height: 40px;
            line-height: 1.4;
        }
        #attachment-modal-save-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 25px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
        }
        .attachment-ghost {
            position: fixed;
            font-size: 40px;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            transform: translate(-50%, -50%);
            color: #333;
        }

        .confirmation-modal-content {
            /* Styles are now combined with .attachment-modal-content */
        }
        #confirmation-modal-icon {
            font-size: 32px; margin: 0 0 15px 0; color: var(--delete-color);
        }
        #confirmation-modal-message {
            margin: 0 0 25px 0; font-size: 16px; line-height: 1.5; color: #333;
        }
        .confirmation-modal-buttons {
            display: flex; justify-content: center; gap: 15px;
        }
        .confirmation-modal-buttons button {
            border: none; padding: 10px 25px; border-radius: 8px; font-size: 16px; cursor: pointer; transition: background-color 0.2s ease;
        }
        #confirmation-modal-cancel-btn {
            background-color: #e9e9f0; color: #333;
        }
        #confirmation-modal-confirm-btn {
            background-color: var(--delete-color); color: white;
        }

        @keyframes slide-out-left { to { transform: translateX(-100%); opacity: 0; } }
        @keyframes slide-in-from-right { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slide-out-right { to { transform: translateX(100%); opacity: 0; } }
        @keyframes slide-in-from-left { from { transform: translateX(-100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

        #toast-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background-color: rgba(30, 30, 30, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            z-index: 2000;
            display: flex;
            align-items: center;
            gap: 15px;
            opacity: 0;
            transition: opacity 0.4s ease, transform 0.4s ease;
            pointer-events: none;
        }
        #toast-container.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }
        #toast-message {
            font-size: 14px;
            font-weight: 500;
        }
        #toast-message.error {
            color: #ff8a8a;
        }
         #toast-message.syncing {
            color: #87cefa;
        }
        #toast-authorize-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 6px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s;
        }
         #toast-authorize-btn:hover {
            background-color: #0056b3;
        }

        /* --- MOBILE-SPECIFIC STYLES --- */
        #mobile-bottom-bar { display: none; }

        body.is-mobile header {
            padding-left: 0;
            padding-right: 0;
            cursor: pointer;
        }

        body.is-mobile .header-top-row {
             padding: 0 20px;
        }

        body.is-mobile #filter-bar-container {
            max-height: 0;
            overflow-y: hidden; /* Changed from 'overflow: hidden' to allow horizontal scroll */
            transition: max-height 0.3s ease-in-out;
        }

        body.is-mobile header.filters-visible #filter-bar-container {
            max-height: 45px;
        }
        
        body.is-mobile #filter-bar {
            padding: 0 0 14px 20px;
        }

        body.is-mobile #filter-bar::after {
            flex-basis: 1px;
        }

        body.is-mobile #modal-container {
            align-items: flex-end;
            
        }

        body.is-mobile .modal-content {
            width: 100%;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        body.is-mobile #modal-container.show .modal-content {
            transform: translateY(0);
        }

        body.is-mobile .modal-note {
            border-radius: 20px 20px 0 0;
            max-height: 85vh;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        body.is-mobile .modal-controls {
            padding: 10px 20px 20px 20px;
            margin-top: 0;
            background-color: #fffc79;
        }
        
        body.is-mobile #hibernate-btn {
            background-color: #f5a623;
            width: 50px;
            height: 50px;
            flex-shrink: 0;
        }

        body.is-mobile #confirm-add-btn {
            width: 100%;
            border-radius: 12px;
            height: 50px;
            margin: 0;
        }

        body.is-mobile #mobile-bottom-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 8px 25px;
            padding-bottom: calc(12px + env(safe-area-inset-bottom));
            background: rgba(248, 248, 248, 0.85);
            backdrop-filter: blur(15px);
            border-top: 1px solid rgba(0,0,0,0.1);
            z-index: 150;
            transform: translateY(100%);
            transition: transform 0.5s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        body.is-mobile #mobile-bottom-bar.show {
            transform: translateY(0);
        }

        body.is-mobile #add-task-btn,
        body.is-mobile #sticker-orb {
            position: static;
            transform: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        body.is-mobile.calendar-active #add-task-btn,
        body.is-mobile.calendar-active #sticker-orb {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.8);
        }

        body.is-mobile #add-task-btn {
            width: 42px;
            height: 42px;
            font-size: 24px;
            box-shadow: 0 4px 10px rgba(0, 122, 255, 0.3);
        }
        
        body.is-mobile .sticker-orb-face {
            width: 42px;
            height: 42px;
            font-size: 22px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }

        body.is-mobile .header-top-row {
            justify-content: center;
        }
        body.is-mobile header h1 {
            font-size: 14px;
            font-weight: 500;
            margin-right: 0;
        }
        body.is-mobile #auth-container {
            display: none;
        }
        body.is-mobile .header-top-row > .view-toggle {
            display: none;
        }
        
        body.is-mobile #task-list-view,
        body.is-mobile #calendar-view {
            padding-bottom: 100px;
        }

        body.is-mobile .task-item {
            height: 205px;
        }

        /* --- ARCHIVE VIEW STYLES --- */
        .archive-view-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--background);
            background-image: radial-gradient(circle, var(--dot-color) 1px, transparent 1px);
            background-size: 25px 25px;
            z-index: 500;
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .archive-view-container.show {
            transform: translateY(0);
        }

        .archive-header {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            padding: 14px 0 0 0;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(12px);
            flex-shrink: 0;
            border-bottom: 1px solid #eee;
        }
        body:not(.is-mobile) .archive-header { max-width: 1200px; margin: 0 auto; width: 100%; border-radius: 0 0 12px 12px; }

        .archive-header-top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 26px;
            margin-bottom: 15px;
        }
        .archive-header h2 {
            margin: 0;
            font-size: 18px;
            font-weight: 500;
        }

        .close-archive-btn {
            background: none;
            border: none;
            font-size: 24px;
            font-weight: 300;
            color: #555;
            cursor: pointer;
            line-height: 1;
            padding: 0;
            transition: color 0.2s ease;
        }

        body.is-mobile .archive-header {
            padding: 0;
        }
        body.is-mobile .archive-header-top-row {
            padding: 0 8px;
            margin: 0 20px;
            margin-bottom: 16px;
            margin-top: 10px;
        }
        body.is-mobile #archive-filter-bar {
            padding: 8px 0px 0px 20px;
        }

        #archive-filter-bar-container {
            width: 100%;
            overflow-x: auto;
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        #archive-filter-bar-container::-webkit-scrollbar { display: none; }

        #archive-filter-bar {
            display: flex; gap: 10px; padding: 0 26px 15px 26px;
        }

        #archive-filter-bar::after {
            content: '';
            flex: 0 0 8px; /* Provides a 16px spacer on the right */
        }

        body:not(.is-mobile) .archive-content {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }
        .archive-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 5px 25px 25px;
            text-align: center;
        }

        .archive-month-header {
            display: inline-block;
            padding: 6px 16px;
            margin: 20px 0;
            font-size: 14px;
            font-weight: 600;
            color: #6c757d;
            background-color: #fff;
            border-radius: 20px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.07);
        }

        .archive-month-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 320px);
            gap: 25px;
            justify-content: center;
            padding-bottom: 15px;
        }

        .task-item.is-archived {
            height: 160px;
            text-align: left;
        }

        .task-item.is-archived .task-text-title {
            -webkit-line-clamp: 4;
        }

        .task-item.is-archived .task-content {
            padding-right: 90px;
        }

        .restore-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            cursor: pointer;
            width: 80px;
            align-self: stretch;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            opacity: 0;
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            transform: translateX(100%);
            transition: opacity 0.3s ease, transform 0.3s ease;
            flex-direction: column;
            gap: 4px;
            line-height: 1;
        }

        .task-item.is-archived .restore-btn {
            opacity: 1;
            transform: translateX(0);
            transition-delay: 0.5s;
        }

        .restore-btn-text {
            font-size: 11px;
            font-weight: 500;
        }

        @keyframes fly-out-top-right {
            from {
                transform: scale(1) translate(0, 0) rotate(var(--rotation-deg));
                opacity: 1;
            }
            to {
                transform: scale(0.5) translate(60vw, -60vh) rotate(45deg);
                opacity: 0;
            }
        }

        .task-item.is-archiving {
            animation: fly-out-top-right 0.6s cubic-bezier(0.7, 0.085, 0.8, 0.8) forwards;
            z-index: 20; /* Ensure it flies over other cards */
        }

        @keyframes scale-down-fade-out {
            from {
                transform: scale(1) rotate(var(--rotation-deg));
                opacity: 1;
            }
            to {
                transform: scale(0.8) rotate(var(--rotation-deg));
                opacity: 0;
            }
        }

        .task-item.is-restoring {
            animation: scale-down-fade-out 0.25s cubic-bezier(0.7, 0.085, 0.8, 0.8) forwards;
        }


        body.is-mobile .archive-header {
            padding: 14px 0px;
        }
        body.is-mobile .archive-header h2 {
            font-size: 16px;
            font-weight: 500;
        }
        body.is-mobile .archive-month-header {
            padding-top: 6px;
        }

        body.is-mobile .task-item.is-archived {
            height: 164px;
        }
    </style>
    <script>
        // Apply mobile-specific styles immediately to prevent flash of unstyled content
        if (/Mobi/i.test(navigator.userAgent)) {
            const style = document.createElement('style');
            style.textContent = `
                ::-webkit-scrollbar { display: none; }
                body { -ms-overflow-style: none; scrollbar-width: none; }`;
            document.head.appendChild(style);
        }
    </script>
</head>
<body>
    <div id="splash-screen">
        <div class="splash-logo">
            <svg width="60" height="60" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M19 3H5C3.89543 3 3 3.89543 3 5V19C3 20.1046 3.89543 21 5 21H19C20.1046 21 21 20.1046 21 19V5C21 3.89543 20.1046 3 19 3Z" stroke="#B0B0B0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 8H17" stroke="#B0B0B0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 12H17" stroke="#B0B0B0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M7 16H12" stroke="#B0B0B0" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </div>
        <p>Signing in...</p>
    </div>
    <div class="app-container">
        <header>
            <div class="header-top-row">
                <h1 id="header-title"></h1>
                <div id="auth-container">
                </div>
                <div id="view-toggle" class="view-toggle" title="Switch View">
                    <div class="toggle-option active" data-view="list">üìã</div>
                    <div class="toggle-option" data-view="calendar">üóìÔ∏è</div>
                    <div class="toggle-thumb"></div>
                </div>
            </div>
            <div id="filter-bar-container">
                <div id="filter-bar"></div>
            </div>
        </header>
        <main id="task-list-view"></main>
        <section id="calendar-view">
            <div class="calendar-grid-container">
                <div class="calendar-weekdays"><div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div></div>
                <div id="calendar-wrapper">
                    <div id="calendar-slider">
                        <div id="prev-month-grid" class="calendar-month-grid"></div>
                        <div id="current-month-grid" class="calendar-month-grid"></div>
                        <div id="next-month-grid" class="calendar-month-grid"></div>
                    </div>
                </div>
            </div>
        </section>
        <button id="add-task-btn">+</button>
        <div id="sticker-orb">
            <div class="sticker-orb-face"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg></div>
        </div>
    </div>

    <div id="archive-view" class="archive-view-container">
        <div class="archive-header">
            <div class="archive-header-top-row">
                <h2>Archived Tasks</h2>
                <button id="close-archive-btn" class="close-archive-btn">&times;</button>
            </div>
            <div id="archive-filter-bar-container">
                <div id="archive-filter-bar"></div>
            </div>
        </div>
        <div id="archive-content" class="archive-content"></div>
        <!-- 
            The sticker orb is duplicated here for the archive view.
            It's positioned absolutely within the archive view.
        -->
        <div id="archive-sticker-orb" style="position: absolute; bottom: 30px; left: calc(50% - min(600px, 50vw) + 30px); z-index: 540;">
            <div class="sticker-orb-face"><svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg></div>
        </div>
    </div>

    <div id="modal-container">
        <div class="modal-content">
            <form id="task-form">
                <div class="modal-note">
                    <div id="modal-note-content">
                        <textarea id="task-title-input" placeholder="Task Title..." rows="1" enterkeyhint="done"></textarea>
                        <div id="daily-entries-wrapper"></div>
                    </div>
                    <div id="modal-note-footer">
                        <div class="tag-section-modal">
                            <h3 class="tag-title-modal">People</h3>
                            <div id="people-chip-container" class="chip-container"></div>
                        </div>
                         <div class="tag-section-modal">
                            <h3 class="tag-title-modal">Modules</h3>
                            <div id="module-chip-container" class="chip-container"></div>
                        </div>
                    </div>
                </div>
                <div class="modal-controls">
                    <button id="hibernate-btn" class="modal-btn" type="button">üí§</button>
                    <button id="confirm-add-btn" class="modal-btn" type="submit">&#10003;</button>
                </div>
            </form>
        </div>
    </div>

    <div id="attachment-modal-container">
        <div class="attachment-modal-content">
            <h2 id="attachment-modal-icon"></h2>
            <textarea id="attachment-url-input" placeholder="https://example.com" rows="1"></textarea>
            <button id="attachment-modal-save-btn">Save Link</button>
        </div>
    </div>

    <div id="confirmation-modal-container">
        <div class="confirmation-modal-content">
            <div id="confirmation-modal-icon"></div>
            <p id="confirmation-modal-message"></p>
            <div class="confirmation-modal-buttons">
                <button id="confirmation-modal-cancel-btn">Cancel</button>
                <button id="confirmation-modal-confirm-btn">Yes, Delete</button>
            </div>
        </div>
    </div>

    <div id="toast-container">
        <span id="toast-message"></span>
        <button id="toast-authorize-btn" style="display: none;">Sign In</button>
    </div>

    <!-- GOOGLE API SCRIPTS -->
    <script async defer src="https://apis.google.com/js/api.js" onload="gapiLoaded()"></script>
    <script async defer src="https://accounts.google.com/gsi/client" onload="gisLoaded()"></script>

    <script>
    (function() {
        // --- GOOGLE SHEETS API CONFIG ---
        // !!! IMPORTANT SECURITY WARNING !!!
      
       const API_KEY = 'AIzaSyBCCJqOFUMrtVta4oBBvk_yqjW70HA3GrA'; // Your Google API Key
        const CLIENT_ID = '285573038857-t7fk5aakb0sm1gohisst234bsj1co2s1.apps.googleusercontent.com'; // Your Google OAuth 2.0 Client ID
        const SPREADSHEET_ID = '1J9xENB3Fz3laJlMsz5mdojXu0BbJ3oCNE5LxHRaI128'; // The ID of your Google Spreadsheet
         /*
        const API_KEY = ''; // Your Google API Key
        const CLIENT_ID = ''; // Your Google OAuth 2.0 Client ID
        const SPREADSHEET_ID = ''; // The ID of your Google Spreadsheet
       */ 

        
        const useGoogleSheets = API_KEY && CLIENT_ID && SPREADSHEET_ID;
        const isMobileDevice = /Mobi/i.test(navigator.userAgent);

        // --- GLOBAL APP STATE & VARIABLES ---
        let gapiInited = false;
        let gisInited = false;
        let tokenClient;
        let isAuthorized = false;

        let toastContainerEl, toastMessageEl, toastAuthorizeBtn;
        let toastTimeout = null;
        let tokenRefreshTimeout = null; 

        let tasks = [];
        let holidays = {};
        let allTags = { people: [], modules: [] };
        const noteColors = ['#fffc79', '#a0e7e5', '#f0a8a8', '#b4f8c8', '#fdc7b5'];
        let calendarDate = new Date();
        let currentView = 'list';
        let editingTaskId = null;
        let activeFilterTag = null;

        let currentAttachmentDrop = null;
        let isDraggingAttachment = false;
        let draggedAttachmentGhost = null;
        let lastTouchTarget = null;
        let writeTimeout = null;
        
        const LONG_PRESS_DURATION = 2500;
        let longPressTimer = null;
        let onConfirmCallback = null;
        
        let isKeyboardVisible = false;
        let modalJustOpened = false;
        let appHasLoaded = false;
        let lastScrollY = window.scrollY;
        
        window.gapiLoaded = () => {
            gapi.load('client', initializeGapiClient);
        }

        window.gisLoaded = () => {
            tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: CLIENT_ID,
                scope: 'https://www.googleapis.com/auth/spreadsheets',
                callback: gapiClientCallback,
            });
            gisInited = true;
            tryAppInitialization();
        }

        const initializeGapiClient = async () => {
            await gapi.client.init({ apiKey: API_KEY, discoveryDocs: ["https://sheets.googleapis.com/$discovery/rest?version=v4"] });
            gapiInited = true;
            tryAppInitialization();
        };

const gapiClientCallback = (resp) => {
    if (resp.error) {
        console.log('Silent auth failed or user is signed out:', resp.error);
        updateSigninStatus(false);
        return;
    }
    
    // Clear any previous refresh timer
    clearTimeout(tokenRefreshTimeout);

    // Google's token expires in 3600 seconds (1 hour). We'll request a new one
    // a minute before it expires to be safe.
    const refreshDelay = (parseInt(resp.expires_in, 10) - 60) * 1000;
    
    // Set the timer only if the delay is a positive number
    if (refreshDelay > 0) {
        tokenRefreshTimeout = setTimeout(() => {
            console.log('Proactively refreshing access token...');
            setStatus('Refreshing session...');
            // Silently request a new token. This function will be called again on success.
            tokenClient.requestAccessToken({ prompt: 'none' }); 
        }, refreshDelay);
    }
    
    updateSigninStatus(true);
};

        const handleAuthClick = () => tokenClient.requestAccessToken({ prompt: 'consent' });

        const updateSigninStatus = (isSignedIn) => {
            isAuthorized = isSignedIn;
            if (isAuthorized) {
                toastContainerEl.classList.remove('show');
                setStatus('Connected');
                loadData();
            } else {
                hideSplashScreen();
                toastMessageEl.textContent = 'Sync to Google Sheets';
                toastMessageEl.className = 'toast-message';
                toastAuthorizeBtn.style.display = 'block';
                toastContainerEl.classList.add('show');
                clearTimeout(toastTimeout);

                tasks = [];
                holidays = {};
                allTags = { people: [], modules: [] };
                renderCurrentView();
            }
        };

        const setStatus = (message, isError = false) => {
            if (!toastMessageEl || !toastContainerEl) return;

            clearTimeout(toastTimeout);
            toastAuthorizeBtn.style.display = 'none';
            toastMessageEl.textContent = message;
            
            toastMessageEl.className = 'toast-message';
            if (isError) toastMessageEl.classList.add('error');
            if (['Syncing...', 'Saving...', 'Reading data...'].includes(message)) {
                toastMessageEl.classList.add('syncing');
            }

            toastContainerEl.classList.add('show');
            toastTimeout = setTimeout(() => {
                toastContainerEl.classList.remove('show');
            }, 3000);
        }

        const tryAppInitialization = () => {
            if (useGoogleSheets && gapiInited && gisInited) {
                tokenClient.requestAccessToken({ prompt: 'none' });
            }
        }
        
        const isHoliday = (date) => {
            const d = new Date(date);
            d.setHours(12, 0, 0, 0); // Avoid timezone issues by normalizing to noon
            const dateStr = toYYYYMMDD(d);

            if (holidays.hasOwnProperty(dateStr)) {
                return holidays[dateStr];
            }

            const dayOfWeek = d.getDay();
            return dayOfWeek === 0 || dayOfWeek === 6; // Sunday or Saturday
        };

        const toggleHoliday = (dateStr) => {
            const d = new Date(dateStr + 'T12:00:00');
            const currentStatus = isHoliday(d);
            
            const dayOfWeek = d.getDay();
            const isDefaultHoliday = dayOfWeek === 0 || dayOfWeek === 6;

            if (currentStatus) { // Currently a holiday, so we mark it as a working day
                if (isDefaultHoliday) {
                    holidays[dateStr] = false; // Add an exception for a weekend day
                } else {
                    delete holidays[dateStr]; // Remove the exception for a weekday
                }
            } else { // Currently a working day, so we mark it as a holiday
                if (isDefaultHoliday) {
                    delete holidays[dateStr]; // It was a weekend marked as working, remove the exception
                } else {
                    holidays[dateStr] = true; // Add an exception for a weekday
                }
            }
            
            saveData();
            
            if (currentView === 'calendar') {
                renderCalendar();
            } else {
                 renderTasks(true);
            }
            
            const modalContainer = document.getElementById('modal-container');
            if (modalContainer.classList.contains('show') && editingTaskId) {
                const task = tasks.find(t => t.id === editingTaskId);
                showModal(task);
            }
        };
        
        const calculateActiveDays = (task) => {
            if (!task.completedAt) return 0;
            let activeDays = 0;
            const startDate = startOfDay(new Date(task.createdAt));
            const endDate = startOfDay(new Date(task.completedAt));

            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                if (!isHoliday(d) && !isDateInHibernation(d, task)) {
                    activeDays++;
                }
            }
            return Math.max(1, activeDays);
        };


        const loadData = async () => {
            if (useGoogleSheets) {
                if (isAuthorized) {
                   await readFromSheet();
                }
            } else {
                const storedTasks = localStorage.getItem('tasks');
                if (storedTasks) {
                    tasks = JSON.parse(storedTasks);
                } else {
                    const thirtyDaysAgo = new Date(); thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                    const tenDaysAgo = new Date(); tenDaysAgo.setDate(tenDaysAgo.getDate() - 10);
                    const fiveDaysAgo = new Date(); fiveDaysAgo.setDate(fiveDaysAgo.getDate() - 5);
                    tasks = [{
                        id: 99999,
                        title: 'Project Alpha design phase',
                        content: {
                            [toYYYYMMDD(thirtyDaysAgo)]: "Initial research and mood board creation.",
                            [toYYYYMMDD(tenDaysAgo)]: "Finalized the color palette and typography.",
                            [toYYYYMMDD(fiveDaysAgo)]: "Completed wireframes for the main dashboard."
                        },
                        createdAt: thirtyDaysAgo.toISOString(),
                        completedAt: fiveDaysAgo.toISOString(),
                        archived: false,
                        tags: { people: ['Alice'], modules: ['API'] },
                        attachments: []
                    }];
                }
                tasks.forEach(parseTaskHibernation);
                const storedHolidays = localStorage.getItem('holidays');
                if (storedHolidays) {
                    holidays = JSON.parse(storedHolidays);
                }
                allTags = JSON.parse(localStorage.getItem('allTags')) || { people: ['Alice', 'Bob'], modules: ['Frontend', 'API', 'Database'] };
                renderCurrentView(true, null, null);
                setTimeout(hideSplashScreen, 500);
            }
        };

        const saveData = () => {
             if (useGoogleSheets) {
                if (isAuthorized) {
                    setStatus('Syncing...');
                    clearTimeout(writeTimeout);
                    writeTimeout = setTimeout(async () => {
                        await writeToSheet();
                    }, 2000);
                }
            } else {
                const tasksToSave = tasks.map(prepareTaskForSaving);
                localStorage.setItem('tasks', JSON.stringify(tasksToSave));
                localStorage.setItem('holidays', JSON.stringify(holidays));
                localStorage.setItem('allTags', JSON.stringify(allTags));
            }
        };
        
        const parseTaskHibernation = (task) => {
            if (task.content && task.content._hibernation) {
                task.hibernationPeriods = task.content._hibernation;
                delete task.content._hibernation;
            } else {
                task.hibernationPeriods = [];
            }
        };

        const prepareTaskForSaving = (task) => {
            const taskCopy = JSON.parse(JSON.stringify(task));
            if (taskCopy.hibernationPeriods && taskCopy.hibernationPeriods.length > 0) {
                if (!taskCopy.content) taskCopy.content = {};
                taskCopy.content._hibernation = taskCopy.hibernationPeriods;
            }
            delete taskCopy.hibernationPeriods;
            return taskCopy;
        };

        const readFromSheet = async () => {
            setStatus('Reading data...');
            try {
                const response = await gapi.client.sheets.spreadsheets.values.batchGet({
                    spreadsheetId: SPREADSHEET_ID,
                    ranges: ['tasks!A:H', 'tags!A:B', 'holidays!A:B'],
                });

                const taskValueRange = response.result.valueRanges?.[0];
                const tagValueRange = response.result.valueRanges?.[1];
                const holidayValueRange = response.result.valueRanges?.[2];

                const taskRows = taskValueRange?.values || [];
                const tagRows = tagValueRange?.values || [];
                const holidayRows = holidayValueRange?.values || [];

                const parsedTasks = [];
                if (taskRows.length > 1) {
                    taskRows.slice(1).forEach((row, index) => {
                        try {
                            if (!Array.isArray(row)) return;
                            const task = {
                                id: parseInt(row[0], 10),
                                title: row[1] || 'Untitled Task',
                                content: JSON.parse(row[2] || '{}'),
                                createdAt: row[3],
                                completedAt: row[4] || null,
                                archived: row[5] === 'TRUE',
                                tags: JSON.parse(row[6] || '{}'),
                                attachments: JSON.parse(row[7] || '[]')
                            };
                            if (isNaN(task.id) || !task.createdAt) return;
                            parseTaskHibernation(task);
                            parsedTasks.push(task);
                        } catch (e) {
                            console.error(`Error parsing row ${index + 2} from 'tasks' sheet:`, e);
                        }
                    });
                }
                tasks = parsedTasks;

                const parsedTags = { people: [], modules: [] };
                if (tagRows.length > 1) {
                    tagRows.slice(1).forEach((row, index) => {
                        try {
                            if (!Array.isArray(row) || row.length < 2) return;
                            const [category, tag] = row;
                            if (category && tag && parsedTags.hasOwnProperty(category)) {
                                parsedTags[category].push(tag);
                            }
                        } catch (e) {
                             console.error(`Error parsing row ${index + 2} from 'tags' sheet:`, e);
                        }
                    });
                }
                allTags = parsedTags;
                
                const parsedHolidays = {};
                if (holidayRows.length > 1) {
                    holidayRows.slice(1).forEach((row, index) => {
                        try {
                            if (!Array.isArray(row) || row.length < 2) return;
                            const [dateStr, isHolidayStr] = row;
                            if (dateStr) {
                                parsedHolidays[dateStr] = (isHolidayStr === 'TRUE');
                            }
                        } catch (e) {
                            console.error(`Error parsing row ${index + 2} from 'holidays' sheet:`, e);
                        }
                    });
                }
                holidays = parsedHolidays;

                setStatus('Data loaded');
            } catch (err) {
                console.error('Error reading from sheet:', err);
                setStatus('Read Error', true);
            }
            renderCurrentView(true, null, null);
            hideSplashScreen();
        };

       const writeToSheet = async () => {
    if (!isAuthorized) return;
    setStatus('Saving...');
    try {
        // Prepare tasks data
        const tasksToSave = tasks.map(prepareTaskForSaving);
        const taskValues = [
            ['id', 'title', 'content', 'createdAt', 'completedAt', 'archived', 'tags', 'attachments'],
            ...tasksToSave.map(task => [
                task.id,
                task.title,
                JSON.stringify(task.content || {}),
                task.createdAt,
                task.completedAt || null,
                task.archived ? 'TRUE' : 'FALSE',
                JSON.stringify(task.tags || {}),
                JSON.stringify(task.attachments || [])
            ])
        ];

        // Prepare tags data
        const tagValues = [
            ['category', 'tag'],
            ...allTags.people.map(tag => ['people', tag]),
            ...allTags.modules.map(tag => ['modules', tag])
        ];
        
        // Prepare holidays data
        const holidayValues = [
            ['date', 'isHoliday'],
            ...Object.entries(holidays).map(([date, isHoliday]) => [date, isHoliday ? 'TRUE' : 'FALSE'])
        ];

        // Clear existing data from row 2 downwards
        await gapi.client.sheets.spreadsheets.values.batchClear({
            spreadsheetId: SPREADSHEET_ID,
            resource: { ranges: ['tasks!A2:H', 'tags!A2:B', 'holidays!A2:B'] }
        });

        // Write all data starting from row 1
        await gapi.client.sheets.spreadsheets.values.batchUpdate({
            spreadsheetId: SPREADSHEET_ID,
            resource: {
                valueInputOption: 'USER_ENTERED',
                data: [
                    { range: 'tasks!A1', values: taskValues },
                    { range: 'tags!A1', values: tagValues },
                    { range: 'holidays!A1', values: holidayValues }
                ]
            }
        });
        
        setStatus('Saved');
    } catch (err) {
        // Check if the error is due to an expired token (401 Unauthorized)
        if (err.status === 401) {
            console.log('Token expired. Attempting silent refresh...');
            setStatus('Re-syncing...');
            
            // Attempt to get a new token silently.
            tokenClient.requestAccessToken({
                prompt: 'none',
                callback: async (response) => {
                    if (response.error) {
                        // If silent refresh fails, the user must sign in again.
                        console.error('Silent refresh failed:', response.error);
                        setStatus('Sync failed. Please sign in.', true);
                        updateSigninStatus(false);
                    } else {
                        // If refresh succeeds, recursively call this function to retry saving.
                        console.log('Token refreshed successfully. Retrying save...');
                        await writeToSheet();
                    }
                }
            });
        } else {
            // Handle other types of errors (e.g., network issues)
            console.error('Error writing to sheet:', err);
            setStatus('Save Error', true);
        }
    }
};

        const isTaskHibernated = (task) => {
            if (!task.hibernationPeriods || task.hibernationPeriods.length === 0) {
                return false;
            }
            const lastPeriod = task.hibernationPeriods[task.hibernationPeriods.length - 1];
            return !lastPeriod.end;
        };
        
        const getTaskStatus = (task) => {
            if (task.completedAt) return 2;
            if (isTaskHibernated(task)) return 1;
            return 0;
        };
        
        const sortTasks = () => {
            tasks.sort((a, b) => {
                const statusA = getTaskStatus(a);
                const statusB = getTaskStatus(b);
        
                if (statusA !== statusB) {
                    return statusA - statusB;
                }
        
                if (statusA === 2) {
                    return new Date(b.completedAt) - new Date(a.completedAt);
                } else {
                    return new Date(b.createdAt) - new Date(a.createdAt);
                }
            });
        };

        const renderCurrentView = (initialLoad = false, newTaskId = null, editedTaskId = null) => {
            const archiveView = document.getElementById('archive-view');
            const isArchiveVisible = archiveView.classList.contains('show');

            const runIntroAnimation = initialLoad && !appHasLoaded;
            
            if (isArchiveVisible) {
                const archiveContent = document.getElementById('archive-content');
                renderArchivedTasks(archiveContent, false); // Rerender archive with layout animation
                renderTasks(false, newTaskId, editedTaskId, false, true); // Rerender main list in background without animation
            } else if(currentView === 'list') {
                renderTasks(true, newTaskId, editedTaskId, runIntroAnimation, false);
            } else {
                renderCalendar();
            }

            if (runIntroAnimation) {
                appHasLoaded = true;
                if (isMobileDevice) {
                    const visibleTasks = getFilteredTasks().filter(task => !task.archived);
                    const cardAnimationTime = (visibleTasks.length * 65) + 500; 
                    setTimeout(() => {
                        const mobileBar = document.getElementById('mobile-bottom-bar');
                        if (mobileBar) {
                            mobileBar.style.bottom = '1px';
                            void mobileBar.offsetHeight;
                            mobileBar.style.bottom = '';

                            requestAnimationFrame(() => {
                                mobileBar.classList.add('show');
                            });
                        }
                    }, cardAnimationTime);
                }
            }
        };

        const startOfDay = (d) => { const date = new Date(d); date.setHours(0, 0, 0, 0); return date; };
        const toYYYYMMDD = (d) => {
            const year = d.getFullYear();
            const month = (d.getMonth() + 1).toString().padStart(2, '0');
            const day = d.getDate().toString().padStart(2, '0');
            return `${year}-${month}-${day}`;
        };
        const getFilteredTasks = () => {
            if (!activeFilterTag || activeFilterTag === 'archived') return tasks;
            return tasks.filter(task => {
                const allTaskTags = [...(task.tags?.people || []), ...(task.tags?.modules || [])];
                return allTaskTags.includes(activeFilterTag);
            });
        };
        const getRelativeTime = (dateString) => {
            const date = new Date(dateString);
            const now = new Date();
            const diffTime = Math.abs(now - date);
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
            if (diffDays === 0) return 'today';
            if (diffDays === 1) return 'yesterday';
            return `${diffDays} days ago`;
        };
        const autoGrow = (element) => {
            element.style.height = '1px';
            element.style.height = (element.scrollHeight) + 'px';
        };

        const renderFilterBar = () => {
            const filterBar = document.getElementById('filter-bar');
            const tagCounts = {};

            tasks.filter(t => !t.archived).forEach(task => {
                const allTaskTags = [...(task.tags?.people || []), ...(task.tags?.modules || [])];
                allTaskTags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            });

            const sortedTags = Object.keys(tagCounts).sort((a, b) => tagCounts[b] - tagCounts[a]);
            filterBar.innerHTML = '';

            sortedTags.forEach(tag => {
                const chip = document.createElement('div');
                chip.className = 'filter-chip';
                chip.textContent = tag;
                chip.dataset.tag = tag;
                if (activeFilterTag === tag) chip.classList.add('active');
                filterBar.appendChild(chip);
            });

            const archiveChip = document.createElement('div');
            archiveChip.className = 'filter-chip filter-chip--archive';
            archiveChip.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 6px; vertical-align: -3px;"><path d="M21 8v13H3V8"/><path d="M1 3h22v5H1z"/><path d="M10 12h4"/></svg>Archived`;
            archiveChip.dataset.tag = 'archived';
            if (activeFilterTag === 'archived') archiveChip.classList.add('active');
            filterBar.appendChild(archiveChip);
        };

        const renderTasks = (animateLayout = false, newTaskId = null, editedTaskId = null, initialLoad = false, forceNoAnimation = false) => {
            const taskListView = document.getElementById('task-list-view');

            renderFilterBar();

            taskListView.style.display = 'grid';

            const firstPositions = new Map();
            if (animateLayout && !forceNoAnimation) {
                taskListView.querySelectorAll('.task-item').forEach(el => {
                    const style = window.getComputedStyle(el);
                    firstPositions.set(el.dataset.id, {
                        rect: el.getBoundingClientRect(),
                        rotation: style.getPropertyValue('--rotation-deg')
                    });
                });
            }

            sortTasks();
            
            taskListView.innerHTML = '';
            const filteredTasks = getFilteredTasks();
            const visibleTasks = filteredTasks.filter(task => !task.archived);
            visibleTasks.forEach((task, index) => {
                const taskItem = document.createElement('div');
                taskItem.className = 'task-item';
                
                const isHibernated = isTaskHibernated(task);
                const isNewNote = (newTaskId && newTaskId === task.id);
                const isAnimatingIn = (initialLoad || isNewNote) && !forceNoAnimation;

                if (isAnimatingIn) {
                    taskItem.classList.add('is-entering');
                    const initialLoadDelay = 150;
                    const enterDelay = initialLoad ? initialLoadDelay + (index * 65) : 10;
                    const enterTransitionDuration = 500;
                    
                    setTimeout(() => {
                        requestAnimationFrame(() => {
                            taskItem.classList.remove('is-entering');
                        });
                    }, enterDelay);

                    if (task.completedAt) {
                        setTimeout(() => {
                            taskItem.classList.add('completed');
                        }, enterDelay + enterTransitionDuration);
                    } else if (isHibernated) {
                        setTimeout(() => {
                            taskItem.classList.add('hibernated');
                        }, enterDelay + enterTransitionDuration);
                    }
                } else {
                    if (task.completedAt) {
                        taskItem.classList.add('completed');
                    } else if (isHibernated) {
                        taskItem.classList.add('hibernated');
                    }
                }
                
                if (editedTaskId && editedTaskId === task.id) {
                    taskItem.classList.add('task-edited-animation');
                    taskItem.addEventListener('animationend', () => {
                        taskItem.classList.remove('task-edited-animation');
                    }, { once: true });
                }

                taskItem.dataset.id = task.id;
                taskItem.style.backgroundColor = noteColors[task.id % noteColors.length];
                const rotation = (index % 2 === 0 ? 1.5 : -1.5);
                const startRotation = (rotation > 0) ? -10 : 10;
                taskItem.style.setProperty('--rotation-deg', `${rotation}deg`);
                taskItem.style.setProperty('--start-rotation-deg', `${startRotation}deg`);

                const taskContent = document.createElement('div');
                taskContent.className = 'task-content';

                const timeAgo = document.createElement('div');
                timeAgo.className = 'time-ago';

                const archiveBtn = document.createElement('button');
                archiveBtn.className = 'archive-btn';
                archiveBtn.onclick = (e) => {
                    const taskItemToAnimate = e.currentTarget.closest('.task-item');
                    if (taskItemToAnimate) {
                        // Prevent other interactions while animating
                        taskItemToAnimate.style.pointerEvents = 'none';
                        taskItemToAnimate.classList.add('is-archiving');
                        taskItemToAnimate.addEventListener('animationend', () => {
                            archiveTask(task.id);
                        }, { once: true });
                    }
                };

                if (task.completedAt) {
                    const completionDate = new Date(task.completedAt);
                    timeAgo.textContent = `Completed on ${completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
                    const daysTaken = calculateActiveDays(task);
                    archiveBtn.innerHTML = `<div>&#10003;</div><div class="days-to-complete">Took ${daysTaken} day${daysTaken !== 1 ? 's' : ''}</div>`;
                } else if (isTaskHibernated(task)) {
                     timeAgo.textContent = `Hibernated`;
                }
                else {
                    timeAgo.textContent = getRelativeTime(task.createdAt);
                    archiveBtn.innerHTML = '&#10003;';
                }
                taskContent.appendChild(timeAgo);

                const textDisplay = document.createElement('div');
                textDisplay.className = 'task-text-display';

                const titleDisplay = document.createElement('div');
                titleDisplay.className = 'task-text-title';
                titleDisplay.textContent = task.title || 'Untitled Task';
                textDisplay.appendChild(titleDisplay);

                let latestEntryDisplay = null;
                if (task.content) {
                    const contentKeys = Object.keys(task.content).sort().reverse();
                    if (contentKeys.length > 0) {
                        const latestEntryText = task.content[contentKeys[0]];
                        latestEntryDisplay = document.createElement('div');
                        latestEntryDisplay.className = 'task-text-latest-entry';
                        latestEntryDisplay.textContent = latestEntryText;
                        textDisplay.appendChild(latestEntryDisplay);
                    }
                }
                taskContent.appendChild(textDisplay);

                const tagsContainer = document.createElement('div');
                tagsContainer.className = 'task-tags-container';
                if (task.tags) {
                    const allTaskTags = [...(task.tags.people || []), ...(task.tags.modules || [])];
                    allTaskTags.forEach(tagText => {
                        const tagEl = document.createElement('span');
                        tagEl.className = 'task-tag';
                        tagEl.textContent = tagText;
                        tagsContainer.appendChild(tagEl);
                    });
                }
                taskItem.appendChild(taskContent);
                taskItem.appendChild(tagsContainer);

                const attachmentDisplay = document.createElement('div');
                attachmentDisplay.className = 'sticker-display-area'; 
                if (task.attachments) {
                    const figmaIconHTML = `<img src="figma.png" alt="Figma Icon" width="22" height="22">`;
                    const jiraIconHTML = `<img src="jira.png" alt="Jira Icon" width="22" height="22">`;
                    task.attachments.forEach((attachment, attachmentIndex) => {
                        const attachmentLink = document.createElement('a');
                        attachmentLink.className = 'sticker-link';
                        if (attachment.url.includes('figma.com')) {
                            attachmentLink.innerHTML = figmaIconHTML;
                        } else if (attachment.url.includes('atlassian.net')) {
                            attachmentLink.innerHTML = jiraIconHTML;
                        } else {
                            attachmentLink.textContent = 'üìÑ';
                        }
                        attachmentLink.href = attachment.url;
                        attachmentLink.target = '_blank';
                        
                        const handlePressStart = (e) => {
                            e.stopPropagation();
                            clearTimeout(longPressTimer);                           
                            longPressTimer = setTimeout(() => {
                                const icon = attachmentLink.innerHTML;
                                showConfirmationModal(icon, 'Are you sure you want to delete this attachment?', () => deleteAttachment(task.id, attachmentIndex));
                            }, LONG_PRESS_DURATION);
                        };
                        const handlePressEnd = (e) => {
                            e.stopPropagation();
                            clearTimeout(longPressTimer);
                        };
                        attachmentLink.addEventListener('mousedown', handlePressStart);
                        attachmentLink.addEventListener('touchstart', handlePressStart, { passive: true });
                        attachmentLink.addEventListener('mouseup', handlePressEnd);
                        attachmentLink.addEventListener('mouseleave', handlePressEnd);
                        attachmentLink.addEventListener('touchend', handlePressEnd);
                        attachmentLink.addEventListener('touchcancel', handlePressEnd);

                        attachmentLink.onclick = (e) => {
                             if (longPressTimer) {
                                clearTimeout(longPressTimer);
                                // A normal click should not open the link if a long-press timer was active.
                                // Instead, we check if the press was short enough to be a click.
                                // But since a normal click should open the link, we let it propagate
                                // only if the timeout wasn't fired, which is handled by clearing it.
                             }
                        };

                        attachmentDisplay.appendChild(attachmentLink);
                    });
                }
                if (isTaskHibernated(task)) {
                    const hibernateIcon = document.createElement('div');
                    hibernateIcon.textContent = 'üí§';
                    hibernateIcon.style.fontSize = '20px';
                    attachmentDisplay.appendChild(hibernateIcon);
                }
                taskItem.appendChild(attachmentDisplay);

                const uncompletePlaceholder = document.createElement('div');
                uncompletePlaceholder.className = 'uncomplete-placeholder';
                uncompletePlaceholder.innerHTML = '&#8634;';

                taskItem.appendChild(uncompletePlaceholder);
                taskItem.appendChild(archiveBtn);
                taskListView.appendChild(taskItem);

                const titleLineHeight = parseInt(window.getComputedStyle(titleDisplay).lineHeight, 10);
                if (titleLineHeight > 0 && latestEntryDisplay) {
                    const titleLines = Math.round(titleDisplay.scrollHeight / titleLineHeight);
                    latestEntryDisplay.style.webkitLineClamp = titleLines > 1 ? '2' : '3';
                }
            });

            if (animateLayout && !forceNoAnimation) {
                const elementsToAnimate = [];

                taskListView.querySelectorAll('.task-item:not(.new-note-animation)').forEach(el => {
                    const id = el.dataset.id;
                    const first = firstPositions.get(id);
                    if (first) {
                        const last = el.getBoundingClientRect();
                        const deltaX = first.rect.left - last.left;
                        const deltaY = first.rect.top - last.top;
                        
                        const newRotation = window.getComputedStyle(el).getPropertyValue('--rotation-deg');

                        if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1 || first.rotation.trim() !== newRotation.trim()) {
                             elementsToAnimate.push({ el, deltaX, deltaY, oldRotation: first.rotation, newRotation });
                        }
                    }
                });

                elementsToAnimate.forEach(({ el, deltaX, deltaY, oldRotation }) => {
                    el.style.transition = 'none';
                    el.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${oldRotation})`;
                });
                
                void taskListView.offsetWidth;

                setTimeout(() => {
                    elementsToAnimate.forEach(({ el, newRotation }) => {
                        el.style.transition = 'transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1)';
                        el.style.transform = `rotate(${newRotation})`;

                        el.addEventListener('transitionend', (e) => {
                            if (e.propertyName === 'transform') {
                                el.style.transition = '';
                                el.style.transform = '';
                            }
                        }, { once: true });
                    });
                }, 150);
            }
        };

        const renderArchiveFilterBar = () => {
            const filterBar = document.getElementById('archive-filter-bar');
            if (!filterBar) return;

            const tagCounts = {};
            tasks.filter(t => t.archived).forEach(task => {
                const allTaskTags = [...(task.tags?.people || []), ...(task.tags?.modules || [])];
                allTaskTags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            });

            const sortedTags = Object.keys(tagCounts).sort((a, b) => tagCounts[b] - tagCounts[a]);
            filterBar.innerHTML = '';

            sortedTags.forEach(tag => {
                const chip = document.createElement('div');
                chip.className = 'filter-chip';
                chip.textContent = tag;
                chip.dataset.tag = tag;
                if (activeFilterTag === tag) chip.classList.add('active');
                filterBar.appendChild(chip);
            });
        };

        const renderArchivedTasks = (container, animateIn = false) => {
            const firstPositions = new Map();
            // Only animate layout if we are NOT doing the initial "animateIn"
            if (!animateIn) {
                container.querySelectorAll('.task-item').forEach(el => {
                    const style = window.getComputedStyle(el);
                    firstPositions.set(el.dataset.id, {
                        rect: el.getBoundingClientRect(),
                        rotation: style.getPropertyValue('--rotation-deg')
                    });
                });
            }

            renderArchiveFilterBar();
            container.innerHTML = '';

            let archivedTasks = tasks.filter(t => t.archived && t.completedAt);

            if (activeFilterTag && activeFilterTag !== 'archived') {
                archivedTasks = archivedTasks.filter(task => [...(task.tags?.people || []), ...(task.tags?.modules || [])].includes(activeFilterTag));
            }
            
            archivedTasks
                .sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt));

            if (archivedTasks.length === 0) {
                container.innerHTML = `<p style="text-align: center; color: #888; margin-top: 50px;">No archived tasks found.</p>`;
                return;
            }

            const groupedByMonth = archivedTasks.reduce((acc, task) => {
                const monthYear = new Date(task.completedAt).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                if (!acc[monthYear]) {
                    acc[monthYear] = [];
                }
                acc[monthYear].push(task);
                return acc;
            }, {});

            let overallIndex = 0;
            Object.keys(groupedByMonth).forEach(monthYear => {
                const monthHeader = document.createElement('h3');
                monthHeader.className = 'archive-month-header';
                monthHeader.textContent = monthYear;
                container.appendChild(monthHeader);

                const monthGrid = document.createElement('div');
                monthGrid.className = 'archive-month-grid';

                groupedByMonth[monthYear].forEach(task => {
                    const taskItem = document.createElement('div');
                    taskItem.className = 'task-item completed is-archived';

                    if (animateIn) {
                        taskItem.classList.add('is-entering');
                    }
                    
                    taskItem.dataset.id = task.id;
                    taskItem.style.backgroundColor = noteColors[task.id % noteColors.length];
                    const rotation = (overallIndex % 2 === 0 ? 1.5 : -1.5);
                    const startRotation = (rotation > 0) ? -10 : 10;
                    taskItem.style.setProperty('--rotation-deg', `${rotation}deg`);
                    taskItem.style.setProperty('--start-rotation-deg', `${startRotation}deg`);
                    
                    if (animateIn) {
                        const enterDelay = 150 + (overallIndex * 65);
                        setTimeout(() => {
                            requestAnimationFrame(() => {
                                taskItem.classList.remove('is-entering');
                            });
                        }, enterDelay);
                    }

                    const taskContent = document.createElement('div');
                    taskContent.className = 'task-content';

                    const timeAgo = document.createElement('div');
                    timeAgo.className = 'time-ago';
                    const completionDate = new Date(task.completedAt);
                    const daysTaken = calculateActiveDays(task);
                    const dateString = completionDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    timeAgo.textContent = `Completed in ${daysTaken} day${daysTaken !== 1 ? 's' : ''} on ${dateString}`;
                    taskContent.appendChild(timeAgo);

                    const textDisplay = document.createElement('div');
                    textDisplay.className = 'task-text-display';

                    const titleDisplay = document.createElement('div');
                    titleDisplay.className = 'task-text-title';
                    titleDisplay.textContent = task.title || 'Untitled Task';
                    textDisplay.appendChild(titleDisplay);

                    taskContent.appendChild(textDisplay);

                    const tagsContainer = document.createElement('div');
                    tagsContainer.className = 'task-tags-container';
                    if (task.tags) {
                        const allTaskTags = [...(task.tags.people || []), ...(task.tags.modules || [])];
                        allTaskTags.forEach(tagText => {
                            const tagEl = document.createElement('span');
                            tagEl.className = 'task-tag';
                            tagEl.textContent = tagText;
                            tagsContainer.appendChild(tagEl);
                        });
                    }
                    
                    const attachmentDisplay = document.createElement('div');
                    attachmentDisplay.className = 'sticker-display-area'; 
                    if (task.attachments) {
                        const figmaIconHTML = `<img src="figma.png" alt="Figma Icon" width="22" height="22">`;
                        const jiraIconHTML = `<img src="jira.png" alt="Jira Icon" width="22" height="22">`;
                        task.attachments.forEach(attachment => {
                            const attachmentLink = document.createElement('a');
                            attachmentLink.className = 'sticker-link';
                            if (attachment.url.includes('figma.com')) {
                                attachmentLink.innerHTML = figmaIconHTML;
                            } else if (attachment.url.includes('atlassian.net')) {
                                attachmentLink.innerHTML = jiraIconHTML;
                            } else {
                                attachmentLink.textContent = 'üìÑ';
                            }
                            attachmentLink.href = attachment.url;
                            attachmentLink.target = '_blank';
                            attachmentLink.addEventListener('click', (e) => e.stopPropagation());
                            attachmentDisplay.appendChild(attachmentLink);
                        });
                    }
                    
                    taskItem.appendChild(taskContent);
                    taskItem.appendChild(tagsContainer);
                    taskItem.appendChild(attachmentDisplay);

                    const restoreBtn = document.createElement('button');
                    restoreBtn.className = 'restore-btn';
                    restoreBtn.innerHTML = `<div>&#8634;</div><div class="restore-btn-text">Restore</div>`;
                    restoreBtn.onclick = (e) => {
                        e.stopPropagation();
                        const taskItemToAnimate = e.currentTarget.closest('.task-item');
                        if (taskItemToAnimate) {
                            taskItemToAnimate.classList.add('is-restoring');
                            taskItemToAnimate.addEventListener('animationend', () => {
                                unarchiveTask(task.id);
                            }, { once: true });
                        }
                    };
                    taskItem.appendChild(restoreBtn);

                    taskItem.addEventListener('click', (e) => {
                        if (e.target.closest('.restore-btn')) return;
                        showModal(task);
                    });

                    monthGrid.appendChild(taskItem);
                    overallIndex++;
                });
                container.appendChild(monthGrid);
            });

            if (!animateIn) {
                const elementsToAnimate = [];

                container.querySelectorAll('.task-item').forEach(el => {
                    const id = el.dataset.id;
                    const first = firstPositions.get(id);
                    if (first) {
                        const last = el.getBoundingClientRect();
                        const deltaX = first.rect.left - last.left;
                        const deltaY = first.rect.top - last.top;
                        
                        const newRotation = window.getComputedStyle(el).getPropertyValue('--rotation-deg');

                        if (Math.abs(deltaX) > 1 || Math.abs(deltaY) > 1 || first.rotation.trim() !== newRotation.trim()) {
                             elementsToAnimate.push({ el, deltaX, deltaY, oldRotation: first.rotation, newRotation });
                        }
                    }
                });

                elementsToAnimate.forEach(({ el, deltaX, deltaY, oldRotation }) => {
                    el.style.transition = 'none';
                    el.style.transform = `translate(${deltaX}px, ${deltaY}px) rotate(${oldRotation})`;
                });
                
                void container.offsetWidth;

                elementsToAnimate.forEach(({ el, newRotation }) => {
                    el.style.transition = 'transform 0.6s cubic-bezier(0.2, 0.8, 0.2, 1)';
                    el.style.transform = `rotate(${newRotation})`;
                    el.addEventListener('transitionend', () => {
                        el.style.transition = ''; el.style.transform = '';
                    }, { once: true });
                });
            }
        };

        const renderChipSection = (container, tags, category) => {
            container.innerHTML = '';
            tags.forEach(tag => { const chip = document.createElement('div'); chip.className = 'chip'; chip.textContent = tag; chip.dataset.tag = tag; container.appendChild(chip); });
            const addBtn = document.createElement('button');
            addBtn.type = 'button';
            addBtn.id = `add-${category}-tag-btn`; 
            addBtn.textContent = '+'; 
            addBtn.className = 'add-tag-btn'; 
            container.appendChild(addBtn);
        };

        const renderAllChips = () => {
            const peopleChipContainer = document.getElementById('people-chip-container');
            const moduleChipContainer = document.getElementById('module-chip-container');
            renderChipSection(peopleChipContainer, allTags.people, 'people');
            renderChipSection(moduleChipContainer, allTags.modules, 'modules');
        };

        const prepareLoadingState = (targetGrid, dateForMonth) => {
            targetGrid.innerHTML = `<div class="loading-text">Loading ${dateForMonth.toLocaleDateString('en-US', { month: 'long' })} Tasks</div>`;
        };

        const isDateInHibernation = (date, task) => {
            if (!task.hibernationPeriods || task.hibernationPeriods.length === 0) return false;
            const checkDate = startOfDay(date).getTime();
            
            for (const period of task.hibernationPeriods) {
                const startDate = startOfDay(new Date(period.start + 'T00:00:00')).getTime();
                const endDate = period.end ? startOfDay(new Date(period.end + 'T00:00:00')).getTime() : Infinity;
                if (checkDate >= startDate && checkDate < endDate) {
                    return true;
                }
            }
            return false;
        };

        const renderSingleMonth = (targetGrid, dateForMonth, tasksForCalendar) => {
            targetGrid.innerHTML = '';
            const gridContentWrapper = document.createElement('div');
            gridContentWrapper.className = 'day-grid-wrapper';

            const today = startOfDay(new Date());
            const month = dateForMonth.getMonth();
            const year = dateForMonth.getFullYear();
            const firstDayOfMonth = new Date(year, month, 1);
            const lastDayOfMonth = new Date(year, month + 1, 0);
            const viewStartDate = new Date(firstDayOfMonth);
            viewStartDate.setDate(viewStartDate.getDate() - viewStartDate.getDay());
            const viewEndDate = new Date(lastDayOfMonth);
            viewEndDate.setDate(viewEndDate.getDate() + (6 - viewEndDate.getDay()));

            const numWeeks = Math.ceil((viewEndDate - viewStartDate) / (86400000 * 7));
            let rowMaxSlots = Array(numWeeks).fill(0);
            
            let dailyTaskSlots = new Map();
            for (let d = new Date(viewStartDate); d <= viewEndDate; d.setDate(d.getDate() + 1)) {
                dailyTaskSlots.set(toYYYYMMDD(d), []);
            }

            tasksForCalendar.forEach(task => {
                const taskStart = startOfDay(new Date(task.createdAt));
                const taskEnd = task.completedAt ? startOfDay(new Date(task.completedAt)) : today;
                
                if (taskEnd < viewStartDate || taskStart > viewEndDate) return;
                
                let slot = 0;
                while (true) {
                    let isSlotTaken = false;
                    for (let d = new Date(taskStart); d <= taskEnd; d.setDate(d.getDate() + 1)) {
                        const dateStr = toYYYYMMDD(d);
                        if (isHoliday(d) || isDateInHibernation(d, task)) continue;
                        if (dailyTaskSlots.has(dateStr) && dailyTaskSlots.get(dateStr)[slot]) {
                            isSlotTaken = true;
                            break;
                        }
                    }
                    if (!isSlotTaken) break;
                    slot++;
                }
                
                for (let d = new Date(taskStart); d <= taskEnd; d.setDate(d.getDate() + 1)) {
                    const dateStr = toYYYYMMDD(d);
                    if (isHoliday(d) || isDateInHibernation(d, task)) continue;
                    if (dailyTaskSlots.has(dateStr)) {
                        dailyTaskSlots.get(dateStr)[slot] = task;
                    }
                }
            });

            for (let i = 0; i < numWeeks; i++) {
                let maxSlotsThisWeek = 0;
                for (let j = 0; j < 7; j++) {
                    const dayDate = new Date(viewStartDate);
                    dayDate.setDate(dayDate.getDate() + (i * 7) + j);
                    const dateStr = toYYYYMMDD(dayDate);
                    if (dailyTaskSlots.has(dateStr)) {
                        // FIX: Instead of counting tasks, get the highest slot used (which is the array's length).
                        // This correctly accounts for empty slots between task bars.
                        const slotsUsedOnDay = dailyTaskSlots.get(dateStr).length;
                        maxSlotsThisWeek = Math.max(maxSlotsThisWeek, slotsUsedOnDay);
                    }
                }
                rowMaxSlots[i] = maxSlotsThisWeek;
            }

            const baseRowHeight = 100;
            const taskBarHeight = 28;
            const rowHeights = [];
            const rowOffsets = [0];
            let totalHeight = 0;

            rowMaxSlots.forEach((maxSlots, i) => {
                let rowHeight = baseRowHeight;
                if (maxSlots > 2) {
                    rowHeight += (maxSlots - 2) * taskBarHeight;
                }
                rowHeights.push(rowHeight);
                totalHeight += rowHeight;
                if (i < rowMaxSlots.length - 1) rowOffsets.push(totalHeight);
            });

            gridContentWrapper.style.gridTemplateRows = rowHeights.map(h => `${h}px`).join(' ');

            for (let d = new Date(viewStartDate); d <= viewEndDate; d.setDate(d.getDate() + 1)) {
                const date = new Date(d);
                const isOtherMonth = date.getMonth() !== month;
                const isToday = date.getTime() === today.getTime();
                const cell = document.createElement('div');
                cell.className = 'day-cell';
                if(isOtherMonth) cell.classList.add('other-month');
                if(isToday) cell.classList.add('today');
                if(isHoliday(date)) cell.classList.add('holiday');
                cell.dataset.date = toYYYYMMDD(date);
                
                const dayNumberDiv = document.createElement('div');
                dayNumberDiv.className = 'day-number';
                dayNumberDiv.textContent = date.getDate();
                dayNumberDiv.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const dateStr = cell.dataset.date;
                    const d = new Date(dateStr + 'T12:00:00');
                    const currentStatus = isHoliday(d);
                    const message = currentStatus ? `Mark ${d.toLocaleDateString('en-US', {weekday: 'short', month: 'short', day: 'numeric'})} as a working day?` : `Mark ${d.toLocaleDateString('en-US', {weekday: 'short', month: 'short', day: 'numeric'})} as a holiday?`;
                    showConfirmationModal('üóìÔ∏è', message, () => toggleHoliday(dateStr));
                    const confirmBtn = document.getElementById('confirmation-modal-confirm-btn');
                    confirmBtn.textContent = 'Yes, Change';
                    confirmBtn.style.backgroundColor = 'var(--accent-color)';
                });
                cell.appendChild(dayNumberDiv);
                gridContentWrapper.appendChild(cell);
            }

            tasksForCalendar.forEach(task => {
                const taskStart = startOfDay(new Date(task.createdAt));
                const taskEnd = task.completedAt ? startOfDay(new Date(task.completedAt)) : today;
                if (taskEnd < viewStartDate || taskStart > viewEndDate) return;

                let currentBarStart = null;
                for (let d = new Date(taskStart); d <= taskEnd; d.setDate(d.getDate() + 1)) {
                    if (isHoliday(d) || isDateInHibernation(d, task)) {
                        if (currentBarStart) {
                            drawBarSegment(currentBarStart, new Date(d.getTime() - 86400000), task);
                            currentBarStart = null;
                        }
                    } else {
                        if (!currentBarStart) {
                            currentBarStart = new Date(d);
                        }
                    }
                }
                if (currentBarStart) {
                    drawBarSegment(currentBarStart, taskEnd, task);
                }
            });
            
            function drawBarSegment(start, end, task) {
                let segmentStart = new Date(start > viewStartDate ? start : viewStartDate);
                while(segmentStart <= end && segmentStart <= viewEndDate) {
                    const dayOfWeek = segmentStart.getDay();
                    const timeDiff = segmentStart.getTime() - viewStartDate.getTime();
                    const dayDiff = Math.floor(timeDiff / 86400000);
                    const rowIndex = Math.floor(dayDiff / 7);
                    const endOfWeek = new Date(segmentStart);
                    endOfWeek.setDate(endOfWeek.getDate() + (6 - dayOfWeek));
                    const barEndDate = end < endOfWeek ? end : endOfWeek;
                    if(barEndDate < viewStartDate) {
                        segmentStart.setDate(segmentStart.getDate() + 7);
                        continue;
                    }

                    const startDateStr = toYYYYMMDD(segmentStart);
                    let slot = -1;
                    if (dailyTaskSlots.has(startDateStr)) {
                        slot = dailyTaskSlots.get(startDateStr).findIndex(t => t && t.id === task.id);
                    }
                    if (slot === -1) { 
                        segmentStart.setDate(segmentStart.getDate() + 7); 
                        continue; 
                    }

                    const span = (barEndDate.getTime() - segmentStart.getTime()) / 86400000 + 1;
                    const taskBar = document.createElement('div');
                    taskBar.className = 'task-bar';
                    if (task.completedAt) {
                        taskBar.classList.add('completed');
                    }
                    taskBar.textContent = task.title;
                    taskBar.style.backgroundColor = noteColors[task.id % noteColors.length].replace('79', 'b3');
                    const prevDayIsInactive = isHoliday(new Date(segmentStart.getTime() - 86400000)) || isDateInHibernation(new Date(segmentStart.getTime() - 86400000), task);
                    if (segmentStart.getDay() === 0 && (start < segmentStart || prevDayIsInactive)) {
                        const prevIndicator = document.createElement('span');
                        prevIndicator.className = 'task-continuation-indicator prev';
                        prevIndicator.textContent = '‚Äπ';
                        taskBar.appendChild(prevIndicator);
                        taskBar.classList.add('has-prev-indicator');
                    }
                    const nextDayIsInactive = isHoliday(new Date(barEndDate.getTime() + 86400000)) || isDateInHibernation(new Date(barEndDate.getTime() + 86400000), task);
                    if (barEndDate.getDay() === 6 && (end > barEndDate || nextDayIsInactive)) {
                        const nextIndicator = document.createElement('span');
                        nextIndicator.className = 'task-continuation-indicator next';
                        nextIndicator.textContent = '‚Ä∫';
                        taskBar.appendChild(nextIndicator);
                        taskBar.classList.add('has-next-indicator');
                    }
                    taskBar.style.top = `${rowOffsets[rowIndex] + 40 + slot * 28}px`;
                    taskBar.style.left = `calc(${(dayOfWeek / 7) * 100}% + 2px)`;
                    taskBar.style.width = `calc(${(span / 7) * 100}% - 4px)`;
                    taskBar.onclick = () => showModal(task);
                    gridContentWrapper.appendChild(taskBar);
                    segmentStart.setDate(segmentStart.getDate() + span);
                }
            }
            
            targetGrid.appendChild(gridContentWrapper);
            return gridContentWrapper;
        };

        const renderCalendar = () => {
            renderFilterBar();
            const slider = document.getElementById('calendar-slider');
            slider.style.transition = 'none';
            slider.style.transform = 'translateX(-33.3333%)';
            const tasksToRender = getFilteredTasks();
            renderSingleMonth(document.getElementById('current-month-grid'), calendarDate, tasksToRender);
            const prevDate = new Date(calendarDate);
            prevDate.setMonth(prevDate.getMonth() - 1);
            const nextDate = new Date(calendarDate);
            nextDate.setMonth(nextDate.getMonth() + 1);
            prepareLoadingState(document.getElementById('prev-month-grid'), prevDate);
            prepareLoadingState(document.getElementById('next-month-grid'), nextDate);
            setTimeout(() => { slider.style.transition = ''; }, 50);
        };

        const showModal = (task = null) => {
            history.pushState({ modalOpen: true }, 'modal');
            document.body.classList.add('modal-open');
            modalJustOpened = true;
            const modalContainer = document.getElementById('modal-container');
            const taskTitleInput = document.getElementById('task-title-input');
            const dailyEntriesWrapper = document.getElementById('daily-entries-wrapper');
            const peopleChipContainer = document.getElementById('people-chip-container');
            const moduleChipContainer = document.getElementById('module-chip-container');
            const hibernateBtn = document.getElementById('hibernate-btn');
            
            const handleFocus = (e) => {
                isKeyboardVisible = true;
                setTimeout(() => {
                    e.target.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 300);
            };

            const handleBlur = () => {
                isKeyboardVisible = false;
            };

            taskTitleInput.addEventListener('focus', handleFocus);
            taskTitleInput.addEventListener('blur', handleBlur);

            editingTaskId = task ? task.id : null;
            renderAllChips();

            if (task) {
                if(task.tags) {
                    peopleChipContainer.querySelectorAll('.chip').forEach(chip => { if (task.tags.people?.includes(chip.dataset.tag)) chip.classList.add('selected'); });
                    moduleChipContainer.querySelectorAll('.chip').forEach(chip => { if (task.tags.modules?.includes(chip.dataset.tag)) chip.classList.add('selected'); });
                }
                
                if (task.completedAt) {
                    hibernateBtn.style.display = 'none';
                } else {
                    hibernateBtn.style.display = 'block';
                    if(isTaskHibernated(task)) {
                        hibernateBtn.textContent = '‚òÄÔ∏è';
                        hibernateBtn.title = 'Wake Up Task';
                    } else {
                        hibernateBtn.textContent = 'üí§';
                        hibernateBtn.title = 'Hibernate Task';
                    }
                }
            } else {
                 hibernateBtn.style.display = 'none';
            }

            taskTitleInput.value = task ? task.title : '';
            dailyEntriesWrapper.innerHTML = '';

            dailyEntriesWrapper.className = 'timeline-view'; // Add class for timeline styling
            const todayStr = toYYYYMMDD(new Date());
            const contentEntries = task ? { ...task.content } : {};
            
            const datesToRender = new Set();
            const hibernationEvents = {}; // Stores the final event type to show for a given day.

            if (task && task.hibernationPeriods && task.hibernationPeriods.length > 0) {
                const eventsByDate = {};
                task.hibernationPeriods.forEach(p => {
                    if (p.start) {
                        if (!eventsByDate[p.start]) eventsByDate[p.start] = [];
                        eventsByDate[p.start].push('hibernated');
                    }
                    if (p.end) {
                        if (!eventsByDate[p.end]) eventsByDate[p.end] = [];
                        eventsByDate[p.end].push('activated');
                    }
                });

                let isTaskActive = true; // A task starts as active.
                const startDate = new Date(task.createdAt);
                const endDate = new Date();

                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    const dateStr = toYYYYMMDD(d);
                    const dailyEvents = eventsByDate[dateStr] || [];
                    
                    if (dailyEvents.length === 0) continue;

                    const wasActiveAtStartOfDay = isTaskActive;
                    
                    // Determine the state at the end of the day based on the last event
                    const lastEvent = dailyEvents[dailyEvents.length - 1];
                    let endsTheDayActive;
                    if (lastEvent === 'activated') {
                        endsTheDayActive = true;
                    } else if (lastEvent === 'hibernated') {
                        endsTheDayActive = false;
                    } else {
                        endsTheDayActive = wasActiveAtStartOfDay;
                    }

                    if (wasActiveAtStartOfDay && !endsTheDayActive) {
                        hibernationEvents[dateStr] = 'hibernated';
                    } else if (!wasActiveAtStartOfDay && endsTheDayActive) {
                        hibernationEvents[dateStr] = 'activated';
                    }
                    isTaskActive = endsTheDayActive;
                }

                Object.keys(hibernationEvents).forEach(dateStr => {
                    if (hibernationEvents[dateStr]) datesToRender.add(dateStr);
                });
            }

            // New Rule: Always prioritize showing "Task Completed" on the end date.
            if (task && task.completedAt) {
                const completedDateStr = toYYYYMMDD(new Date(task.completedAt));
                datesToRender.add(completedDateStr);
                hibernationEvents[completedDateStr] = 'completed';
            }

            // Only add dates with content to the render list.
            Object.keys(contentEntries).forEach(date => {
                if (contentEntries[date]) {
                    datesToRender.add(date);
                }
            });

            // Always ensure today is shown.
            datesToRender.add(todayStr);

            const sortedDates = Array.from(datesToRender).sort((a, b) => new Date(b) - new Date(a));
            sortedDates.forEach(dateStr => {
                const entryContainer = document.createElement('div'); // This is now timeline-entry
                entryContainer.className = 'timeline-entry';

                const marker = document.createElement('div');
                marker.className = 'timeline-marker';
                marker.innerHTML = '<div class="timeline-dot"></div><div class="timeline-line"></div>';
                entryContainer.appendChild(marker);

                const contentWrapper = document.createElement('div');
                contentWrapper.className = 'timeline-content';
                const dateObj = new Date(dateStr + 'T00:00:00');
                const dateHeader = document.createElement('div');
                dateHeader.className = 'daily-entry-date';
                if (isHoliday(dateObj)) {
                    dateHeader.classList.add('is-holiday');
                }
                dateHeader.textContent = dateObj.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

                if (hibernationEvents[dateStr]) {
                    const eventPill = document.createElement('span');
                    eventPill.className = 'hibernation-event-pill';
                    const eventType = hibernationEvents[dateStr];

                    if (eventType === 'hibernated') {
                        eventPill.textContent = 'Task Paused';
                        eventPill.classList.add('hibernated');
                    } else if (eventType === 'activated') {
                        eventPill.textContent = 'Task Resumed';
                        eventPill.classList.add('activated');
                    } else if (eventType === 'completed') {
                        eventPill.textContent = 'Task Completed';
                        eventPill.classList.add('completed');
                    }
                    dateHeader.appendChild(eventPill);
                }

                dateHeader.addEventListener('click', () => {
                    const currentStatus = isHoliday(dateObj);
                    const message = currentStatus ? `Mark ${dateObj.toLocaleDateString('en-US', {weekday: 'short', month: 'short', day: 'numeric'})} as a working day?` : `Mark ${dateObj.toLocaleDateString('en-US', {weekday: 'short', month: 'short', day: 'numeric'})} as a holiday?`;
                    showConfirmationModal('üóìÔ∏è', message, () => toggleHoliday(toYYYYMMDD(dateObj)));
                    const confirmBtn = document.getElementById('confirmation-modal-confirm-btn');
                    confirmBtn.textContent = 'Yes, Change';
                    confirmBtn.style.backgroundColor = 'var(--accent-color)';
                });
                contentWrapper.appendChild(dateHeader);

                const textDisplay = document.createElement('div');
                textDisplay.className = 'daily-entry-textarea'; // Keep class for styling
                textDisplay.dataset.date = dateStr;
                textDisplay.textContent = contentEntries[dateStr] || 'Add a note for today...';
                if (!contentEntries[dateStr]) {
                    textDisplay.style.opacity = '0.6';
                }

                textDisplay.addEventListener('click', () => {
                    if (textDisplay.querySelector('textarea')) return; // Already in edit mode

                    textDisplay.classList.add('is-editing');

                    const currentText = contentEntries[dateStr] || '';
                    textDisplay.innerHTML = ''; // Clear the div
                    textDisplay.style.opacity = '1';

                    const textarea = document.createElement('textarea');
                    textarea.className = 'daily-entry-textarea';
                    textarea.dataset.date = dateStr;
                    textarea.value = currentText;
                    textarea.placeholder = 'Add a note for today...';
                    
                    textarea.addEventListener('input', () => autoGrow(textarea));
                    textarea.addEventListener('focus', handleFocus);
                    textarea.addEventListener('blur', handleBlur);
                    
                    textDisplay.appendChild(textarea);
                    autoGrow(textarea);
                    textarea.focus();
                });
                contentWrapper.appendChild(textDisplay);
                entryContainer.appendChild(contentWrapper);
                dailyEntriesWrapper.appendChild(entryContainer);
            });

            setTimeout(() => autoGrow(taskTitleInput), 0);

            modalContainer.style.display = 'flex';
            setTimeout(() => {
                modalContainer.classList.add('show');
                
                const focusDelay = isMobileDevice ? 350 : 0;

                setTimeout(() => {
                    if (!modalContainer.classList.contains('show')) return;

                    const todayEntryDisplay = dailyEntriesWrapper.querySelector(`.daily-entry-textarea[data-date="${todayStr}"]`);
    
                    if (task && todayEntryDisplay) {
                        // Programmatically click to enter edit mode
                        todayEntryDisplay.click();
                        const textarea = todayEntryDisplay.querySelector('textarea');
                        if (textarea) {
                            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                        }
                        todayEntryDisplay.style.backgroundColor = 'rgba(255, 230, 0, 0.3)';
                        setTimeout(() => {
                            if(todayEntryDisplay) todayEntryDisplay.style.backgroundColor = 'transparent';
                        }, 1500);
                    } else {
                        taskTitleInput.focus();
                    }
                }, focusDelay);

            }, 10);

            setTimeout(() => { modalJustOpened = false; }, 50);
        };

        const hideModal = () => {
            document.body.classList.remove('modal-open');
            const modalContainer = document.getElementById('modal-container');

            // Exit early if the modal isn't showing to prevent errors.
            if (!modalContainer.classList.contains('show')) {
                return;
            }

            // Start the animation by removing the class.
            modalContainer.classList.remove('show');

            const transitionDuration = isMobileDevice ? 300 : 500; // Match CSS transition times

            // After the animation duration, hide the modal and clean up its content.
            setTimeout(() => {
                modalContainer.style.display = 'none';
                const taskTitleInput = document.getElementById('task-title-input');
                const dailyEntriesWrapper = document.getElementById('daily-entries-wrapper');
                taskTitleInput.value = '';
                taskTitleInput.style.height = 'auto';
                dailyEntriesWrapper.innerHTML = '';
                editingTaskId = null;
            }, transitionDuration);
        };

        const showArchiveView = () => {
            history.pushState({ archiveOpen: true }, 'archive');
            document.body.classList.add('modal-open');
            activeFilterTag = null; // Reset filter when opening
            renderFilterBar(); 

            const archiveView = document.getElementById('archive-view');
            const archiveContent = document.getElementById('archive-content');
            renderArchivedTasks(archiveContent, true); // Use true for initial animation
            archiveView.classList.add('show');
        };

        const hideArchiveView = () => {
            const archiveView = document.getElementById('archive-view');
            document.body.classList.remove('modal-open');
            archiveView.classList.remove('show'); 
            activeFilterTag = null;
            renderFilterBar();
        };

        const showAttachmentModal = (taskId) => {
            currentAttachmentDrop = { taskId };
            document.body.classList.add('modal-open');
            const paperclipSVG = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>`;
            const modal = document.getElementById('attachment-modal-container');
            document.getElementById('attachment-modal-icon').innerHTML = paperclipSVG;
            modal.style.display = 'flex';
            const urlInput = document.getElementById('attachment-url-input');
            urlInput.value = '';
            autoGrow(urlInput);
            setTimeout(() => {
                modal.classList.add('show');
                setTimeout(() => {
                    urlInput.focus();
                    urlInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 200);
            }, 10); // Small delay to allow display:flex to apply
        };

        const hideAttachmentModal = () => {
            const modal = document.getElementById('attachment-modal-container');
            document.body.classList.remove('modal-open');
            modal.classList.remove('show');
            modal.addEventListener('transitionend', (e) => {
                if (e.target === modal) {
                    modal.style.display = 'none';
                    currentAttachmentDrop = null;
                }
            }, { once: true });
        };
        
        const showConfirmationModal = (icon, message, onConfirm) => {
            const modal = document.getElementById('confirmation-modal-container');
            document.body.classList.add('modal-open');
            document.getElementById('confirmation-modal-icon').innerHTML = icon;
            document.getElementById('confirmation-modal-message').textContent = message;
            onConfirmCallback = onConfirm;
            modal.style.display = 'flex';
        };

        const hideConfirmationModal = () => {
            document.body.classList.remove('modal-open');
            document.getElementById('confirmation-modal-container').style.display = 'none';
            onConfirmCallback = null;
            // Reset button to default delete style
            const confirmBtn = document.getElementById('confirmation-modal-confirm-btn');
            confirmBtn.textContent = 'Yes, Delete';
            confirmBtn.style.backgroundColor = 'var(--delete-color)';
        };

        const saveAttachment = () => {
            if (!currentAttachmentDrop) return;
            const { taskId } = currentAttachmentDrop;
            const url = document.getElementById('attachment-url-input').value.trim();
            if (!url) return;

            const task = tasks.find(t => t.id === taskId);
            if (task) {
                if (!task.attachments) task.attachments = [];
                if (task.attachments.length < 3) {
                    const newAttachment = { url };
                    // Handle multiple URLs pasted at once
                    const urls = url.split(/\s+/).filter(u => u.startsWith('http'));
                    urls.forEach(u => {
                        if (task.attachments.length < 3) {
                            task.attachments.push({ url: u });
                        }
                    });
                    saveData();
                    renderCurrentView(false, null, task.id);
                }
            }
            hideAttachmentModal();
        };

        const saveTaskFromModal = () => {
            const taskTitleInput = document.getElementById('task-title-input');
            const peopleChipContainer = document.getElementById('people-chip-container');
            const moduleChipContainer = document.getElementById('module-chip-container');
            const dailyEntriesWrapper = document.getElementById('daily-entries-wrapper');

            const title = taskTitleInput.value.trim();
            if (!title) return;

            const selectedPeople = Array.from(peopleChipContainer.querySelectorAll('.chip.selected')).map(c => c.dataset.tag);
            const selectedModules = Array.from(moduleChipContainer.querySelectorAll('.chip.selected')).map(c => c.dataset.tag);
            const taskTags = { people: selectedPeople, modules: selectedModules };

            const newContent = {};
            dailyEntriesWrapper.querySelectorAll('.daily-entry-textarea').forEach(textarea => {
                const date = textarea.dataset.date;
                let text = '';
                const innerTextarea = textarea.querySelector('textarea');
                if (innerTextarea) {
                    text = innerTextarea.value.trim();
                } else if (textarea.style.opacity !== '0.6') { // Don't save placeholder text
                    text = textarea.textContent.trim();
                }
                if (text) { newContent[date] = text; }
            });

            let taskIdForAnimation = null;
            let isNewTask = false;

            if (editingTaskId) {
                const task = tasks.find(t => t.id === editingTaskId);
                if (task) {
                    task.title = title;
                    task.tags = taskTags;
                    task.content = newContent;
                }
                taskIdForAnimation = editingTaskId;
            } else {
                const newTaskId = Date.now();
                tasks.unshift({
                    id: newTaskId,
                    title: title,
                    tags: taskTags,
                    content: newContent,
                    createdAt: new Date().toISOString(),
                    completedAt: null,
                    archived: false,
                    attachments: [],
                    hibernationPeriods: []
                });
                taskIdForAnimation = newTaskId;
                isNewTask = true;
            }
            
            history.back();

            // Defer the data save and re-render to allow the close animation to complete smoothly.
            setTimeout(() => {
                saveData();
                if (isNewTask) {
                    renderTasks(true, taskIdForAnimation);
                } else {
                    renderTasks(false, null, taskIdForAnimation);
                }
            }, 350); // A safe buffer after the 300ms mobile transition.
        };
        
        const toggleHibernation = () => {
            if (!editingTaskId) return;
            const task = tasks.find(t => t.id === editingTaskId);
            if (!task) return;
        
            const today = toYYYYMMDD(new Date());
            const periods = task.hibernationPeriods || [];

            if (isTaskHibernated(task)) {
                // Waking up the task
                const lastPeriod = periods[periods.length - 1];
                if (lastPeriod.start === today) {
                    // If it was hibernated today, just remove the period. It cancels out.
                    periods.pop();
                } else {
                    lastPeriod.end = today;
                }
            } else {
                // Hibernating the task
                const lastPeriod = periods.length > 0 ? periods[periods.length - 1] : null;
                if (lastPeriod && lastPeriod.end === today) {
                    // If it was activated today, just remove the 'end' date.
                    delete lastPeriod.end;
                } else {
                    periods.push({ start: today });
                }
            }
            task.hibernationPeriods = periods;

            history.back();

            // Defer the data save and re-render to allow the close animation to complete smoothly.
            setTimeout(() => {
                saveData();
                renderTasks(true, null, editingTaskId);
            }, 350); // A safe buffer after the 300ms mobile transition.
        };


        const uncompleteTask = (taskId) => {
            const task = tasks.find(t => t.id === taskId);
            if (task && task.completedAt) {
                const completionDate = new Date(task.completedAt);
                const reactivationDate = new Date();
                const gapStartDate = new Date(completionDate);
                gapStartDate.setDate(gapStartDate.getDate() + 1);

                if (startOfDay(gapStartDate) < startOfDay(reactivationDate)) {
                    task.hibernationPeriods.push({ start: toYYYYMMDD(gapStartDate), end: toYYYYMMDD(reactivationDate) });
                    task.hibernationPeriods.sort((a, b) => new Date(a.start) - new Date(b.start));
                }
                
                task.completedAt = null;
                saveData();
                renderTasks(true);
            }
        };

        const completeTask = (taskId) => {
            const task = tasks.find(t => t.id === taskId);
            if (task && !task.completedAt) {
                if (isTaskHibernated(task)) {
                    const lastPeriod = task.hibernationPeriods[task.hibernationPeriods.length - 1];
                    lastPeriod.end = toYYYYMMDD(new Date());
                }
                task.completedAt = new Date().toISOString();
                saveData();
                renderTasks(true);
            }
        };

        const archiveTask = (taskId) => {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.archived = true;
                saveData();
                renderTasks(true);
            }
        };

        const unarchiveTask = (taskId) => {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.archived = false;
                saveData();
                const archiveContent = document.getElementById('archive-content');
                if (archiveContent) {
                    renderArchivedTasks(archiveContent, false); // Use false to trigger layout animation
                }
                if (currentView === 'list') {
                    renderTasks(true);
                }
                setStatus('Task restored');
            }
        };

        const deleteTask = (taskId) => {
            tasks = tasks.filter(t => t.id !== taskId);
            saveData();
            renderTasks(true);
        };

        const deleteAttachment = (taskId, attachmentIndex) => {
            const task = tasks.find(t => t.id === taskId);
            if (task && task.attachments && task.attachments[attachmentIndex]) {
                task.attachments.splice(attachmentIndex, 1);
                saveData();
                renderTasks(false, null, taskId);
            }
        };

        const updateHeader = () => {
    const headerTitle = document.getElementById('header-title');
    if (currentView === 'list') {
        const today = new Date();
        headerTitle.textContent = today.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

        // --- NEW CODE START ---
        // Check if today is a holiday and set the color
        if (isHoliday(today)) {
            headerTitle.style.color = '#e57373'; // A reddish-orange color
        } else {
            headerTitle.style.color = ''; // Reset to default CSS color
        }
        // --- NEW CODE END ---

    } else {
        headerTitle.textContent = calendarDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        // Reset color when switching to calendar view
        headerTitle.style.color = '';
    }
};

        const toggleView = () => {
            const taskListView = document.getElementById('task-list-view');
            const calendarView = document.getElementById('calendar-view');
            const viewToggle = document.getElementById('view-toggle');

            const isSwitchingToCalendar = currentView === 'list';
            if (isSwitchingToCalendar) {
                document.body.classList.add('calendar-active');
                taskListView.style.display = 'none';
                calendarView.style.display = 'block';
                currentView = 'calendar';
                calendarDate = new Date();
                renderCalendar();
            } else {
                document.body.classList.remove('calendar-active');
                taskListView.style.display = 'grid';
                calendarView.style.display = 'none';
                currentView = 'list';
                renderTasks(true); // Animate layout on view switch
            }
            viewToggle.classList.toggle('calendar-mode', isSwitchingToCalendar);
            viewToggle.querySelector('[data-view="list"]').classList.toggle('active', !isSwitchingToCalendar);
            viewToggle.querySelector('[data-view="calendar"]').classList.toggle('active', isSwitchingToCalendar);
            updateHeader();
        };

        let startX = 0, startY = 0, currentX = 0, currentY = 0, isDragging = false, isClick = true, targetTaskElement = null, dragDirectionLock = null;
        let longPressFired = false;

        const onDragStart = (clientX, clientY, target) => {
            if (target.closest('.task-content')) {
                targetTaskElement = target.closest('.task-item');
                isDragging = true;
                isClick = true;
                longPressFired = false;
                startX = clientX;
                startY = clientY;
                dragDirectionLock = null;
                targetTaskElement.querySelector('.task-content').style.transition = 'none';
                target.style.cursor = 'grabbing';

                clearTimeout(longPressTimer);
                longPressTimer = setTimeout(() => {
                    longPressFired = true;
                    isDragging = false; // Prevent click/drag end logic from firing
                    const taskId = parseInt(targetTaskElement.dataset.id, 10);
                    showConfirmationModal('üóëÔ∏è', 'Are you sure you want to delete this task?', () => deleteTask(taskId));
                }, LONG_PRESS_DURATION);
            }
        };

        const onDragMove = (clientX, clientY) => {
            if (!isDragging || !targetTaskElement) return;
            currentX = clientX;
            currentY = clientY;
            let diffX = currentX - startX;
            let diffY = currentY - startY;

            if (Math.abs(diffX) > 5 || Math.abs(diffY) > 5) {
                isClick = false;
                clearTimeout(longPressTimer); 
            }

            if (!dragDirectionLock && !isClick) {
                if (Math.abs(diffY) > Math.abs(diffX)) {
                    dragDirectionLock = 'vertical';
                } else {
                    dragDirectionLock = 'horizontal';
                    targetTaskElement.classList.add('is-interacting');
                }
            }
            
            if (dragDirectionLock === 'horizontal') {
                targetTaskElement.querySelector('.task-content').style.transform = `translateX(${diffX}px)`;
            }
        };

        const onDragEnd = () => {
            clearTimeout(longPressTimer);
            if (!isDragging || !targetTaskElement || longPressFired) {
                isDragging = false;
                targetTaskElement = null;
                return;
            };

            const taskContent = targetTaskElement.querySelector('.task-content');
            const elementToClean = targetTaskElement;

            elementToClean.classList.remove('is-interacting');
            taskContent.style.transition = 'transform 0.3s ease';
            taskContent.style.cursor = 'grab';

            const diffX = currentX - startX;
            const threshold = elementToClean.offsetWidth * 0.75;
            const taskId = parseInt(elementToClean.dataset.id, 10);

            if (isClick) {
                const task = tasks.find(t => t.id === taskId);
                if (task) showModal(task);
                taskContent.style.transform = 'translateX(0)';
            } else if (dragDirectionLock === 'horizontal') {
                const shouldComplete = !elementToClean.classList.contains('completed') && diffX > threshold;
                const shouldUncomplete = elementToClean.classList.contains('completed') && diffX < -threshold;

                if (shouldComplete) {
                    elementToClean.classList.add('is-completing', 'is-sliding-complete');
                    taskContent.addEventListener('transitionend', () => completeTask(taskId), { once: true });
                } else if (shouldUncomplete) {
                    elementToClean.classList.remove('completed');
                    elementToClean.classList.add('is-sliding-uncomplete');
                    taskContent.addEventListener('transitionend', () => uncompleteTask(taskId), { once: true });
                }
                taskContent.style.transform = 'translateX(0)';
            } else {
                 taskContent.style.transform = 'translateX(0)';
            }

            isDragging = false;
            targetTaskElement = null;
            dragDirectionLock = null;
        };

        const handleAddTag = (container, category) => {
            const peopleChipContainer = document.getElementById('people-chip-container');
            const moduleChipContainer = document.getElementById('module-chip-container');
            const selectedPeople = Array.from(peopleChipContainer.querySelectorAll('.chip.selected')).map(c => c.dataset.tag);
            const selectedModules = Array.from(moduleChipContainer.querySelectorAll('.chip.selected')).map(c => c.dataset.tag);

            const addBtn = container.querySelector(`#add-${category}-tag-btn`);
            addBtn.style.display = 'none';
            const input = document.createElement('input');
            input.type = 'text';
            input.id = 'new-tag-input';
            input.placeholder = 'New Tag';
            container.appendChild(input);
            input.focus();

            const finalizeNewTag = () => {
                const newTag = input.value.trim();
                if (newTag && !allTags[category].find(t => t.toLowerCase() === newTag.toLowerCase())) {
                    allTags[category].push(newTag);
                    if (category === 'people') {
                        selectedPeople.push(newTag);
                    } else {
                        selectedModules.push(newTag);
                    }
                    saveData();
                }
                
                renderAllChips();

                peopleChipContainer.querySelectorAll('.chip').forEach(chip => {
                    if (selectedPeople.includes(chip.dataset.tag)) {
                        chip.classList.add('selected');
                    }
                });
                moduleChipContainer.querySelectorAll('.chip').forEach(chip => {
                    if (selectedModules.includes(chip.dataset.tag)) {
                        chip.classList.add('selected');
                    }
                });
            };

            input.addEventListener('blur', finalizeNewTag);
            input.addEventListener('keydown', event => { 
                if (event.key === 'Enter') {
                    event.preventDefault();
                    finalizeNewTag(); 
                }
            });
        };

        const updateGhostPosition = (x, y) => {
            if (draggedAttachmentGhost) {
                draggedAttachmentGhost.style.left = `${x}px`;
                draggedAttachmentGhost.style.top = `${y}px`;
            }
        };

        const handleAttachmentMove = (x, y) => {
            if (!isDraggingAttachment) return;
            updateGhostPosition(x, y);
            if(draggedAttachmentGhost) draggedAttachmentGhost.style.display = 'none';
            const elementUnder = document.elementFromPoint(x, y);
            if(draggedAttachmentGhost) draggedAttachmentGhost.style.display = 'block';
            if (lastTouchTarget && lastTouchTarget !== elementUnder) {
                lastTouchTarget.classList.remove('drag-over');
            }
            const taskItem = elementUnder ? elementUnder.closest('.task-item') : null;
            if (taskItem) {
                taskItem.classList.add('drag-over');
                lastTouchTarget = taskItem;
            } else {
                lastTouchTarget = null;
            }
        };

        const handleAttachmentDrop = () => {
            if (!isDraggingAttachment) return;
            if (lastTouchTarget) {
                lastTouchTarget.classList.remove('drag-over');
                const taskId = parseInt(lastTouchTarget.dataset.id, 10);
                const currentTask = tasks.find(t => t.id === taskId);
                 if (currentTask && (!currentTask.attachments || currentTask.attachments.length < 3)) {
                    showAttachmentModal(taskId);
                }
            }
            if (draggedAttachmentGhost) document.body.removeChild(draggedAttachmentGhost);
            draggedAttachmentGhost = null;
            isDraggingAttachment = false;
            lastTouchTarget = null;
        };

        const initializeAttachmentOrb = () => {
            const orbFace = document.querySelector('#sticker-orb .sticker-orb-face');
            if (!orbFace) return;

            const startDrag = (clientX, clientY) => {
                isDraggingAttachment = true;
                draggedAttachmentGhost = document.createElement('div');
                draggedAttachmentGhost.innerHTML = orbFace.innerHTML;
                draggedAttachmentGhost.className = 'attachment-ghost';
                document.body.appendChild(draggedAttachmentGhost);
                updateGhostPosition(clientX, clientY);
            };

            orbFace.addEventListener('mousedown', (e) => {
                e.preventDefault();
                startDrag(e.clientX, e.clientY);
            });

            orbFace.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                startDrag(touch.clientX, touch.clientY);
            }, { passive: false });
        };

        const initializeArchiveAttachmentOrb = () => {
            const orbFace = document.querySelector('#archive-sticker-orb .sticker-orb-face');
            if (!orbFace) return;

            const startDrag = (clientX, clientY) => {
                isDraggingAttachment = true;
                draggedAttachmentGhost = document.createElement('div');
                draggedAttachmentGhost.innerHTML = orbFace.innerHTML;
                draggedAttachmentGhost.className = 'attachment-ghost';
                document.body.appendChild(draggedAttachmentGhost);
                updateGhostPosition(clientX, clientY);
            };

            orbFace.addEventListener('mousedown', (e) => { e.preventDefault(); startDrag(e.clientX, e.clientY); });
            orbFace.addEventListener('touchstart', (e) => { e.preventDefault(); const touch = e.touches[0]; startDrag(touch.clientX, touch.clientY); }, { passive: false });
        };


        const postSlideReset = () => {
            const slider = document.getElementById('calendar-slider');
            const tasksToRender = getFilteredTasks();
            const currentGrid = document.getElementById('current-month-grid');
            const newContentWrapper = renderSingleMonth(currentGrid, calendarDate, tasksToRender);
            newContentWrapper.style.opacity = '0';
            const prevDate = new Date(calendarDate);
            prevDate.setMonth(prevDate.getMonth() - 1);
            const nextDate = new Date(calendarDate);
            nextDate.setMonth(nextDate.getMonth() + 1);
            prepareLoadingState(document.getElementById('prev-month-grid'), prevDate);
            prepareLoadingState(document.getElementById('next-month-grid'), nextDate);
            slider.style.transition = 'none';
            slider.style.transform = 'translateX(-33.3333%)';
            void slider.offsetWidth;
            newContentWrapper.style.opacity = '1';
        };

        const hideSplashScreen = () => {
            const splash = document.getElementById('splash-screen');
            if (splash) {
                splash.classList.add('hidden');
                splash.addEventListener('transitionend', () => splash.remove(), { once: true });
            }
        };

        let handleDesktopKeys;

        const initializeApp = () => {
            if (isMobileDevice) {
                document.body.classList.add('is-mobile');
                const mobileBottomBar = document.createElement('div');
                mobileBottomBar.id = 'mobile-bottom-bar';
                const stickerOrb = document.getElementById('sticker-orb');
                const viewToggle = document.getElementById('view-toggle');
                const addTaskBtn = document.getElementById('add-task-btn');
                mobileBottomBar.appendChild(stickerOrb);
                mobileBottomBar.appendChild(viewToggle);
                mobileBottomBar.appendChild(addTaskBtn);
                document.body.appendChild(mobileBottomBar);
            }

            history.replaceState({ app_initial_state: true }, '');

            window.addEventListener('popstate', (event) => {
                const modalContainer = document.getElementById('modal-container');
                const archiveView = document.getElementById('archive-view');
                const shouldCloseModal = modalContainer.classList.contains('show');
                const shouldCloseArchive = archiveView.classList.contains('show');

                // Defer the closing action to prevent animation glitches, especially on mobile.
                // This gives the browser a moment to process the history change before rendering the transition.
                setTimeout(() => {
                    if (shouldCloseModal) {
                        hideModal();
                    } else if (shouldCloseArchive) {
                        hideArchiveView();
                    }
                }, 0);

                if (event.state === null || !event.state.app_initial_state) {
                    history.pushState({ app_initial_state: true }, '');
                }
            });

            toastContainerEl = document.getElementById('toast-container');
            toastMessageEl = document.getElementById('toast-message');
            toastAuthorizeBtn = document.getElementById('toast-authorize-btn');
            const taskListView = document.getElementById('task-list-view');
            const calendarView = document.getElementById('calendar-view');
            const modalContainer = document.getElementById('modal-container');
            const taskForm = document.getElementById('task-form');
            const peopleChipContainer = document.getElementById('people-chip-container');
            const moduleChipContainer = document.getElementById('module-chip-container');
            const viewToggle = document.getElementById('view-toggle');
            const taskTitleInput = document.getElementById('task-title-input');
            const calendarSlider = document.getElementById('calendar-slider');
            const confirmationModal = document.getElementById('confirmation-modal-container');

            const header = document.querySelector('header');
            const headerTopRow = document.querySelector('.header-top-row');

            headerTopRow.addEventListener('click', () => {
                if (isMobileDevice) {
                    header.classList.toggle('filters-visible');
                }
            });

            window.addEventListener('scroll', () => {
                if (isMobileDevice && header.classList.contains('filters-visible')) {
                    if (Math.abs(window.scrollY - lastScrollY) > 5) {
                        header.classList.remove('filters-visible');
                    }
                }
                lastScrollY = window.scrollY;
            }, { passive: true });

            document.addEventListener('click', (e) => {
                if (isMobileDevice && header.classList.contains('filters-visible') && !header.contains(e.target)) {
                    header.classList.remove('filters-visible');
                }
            });

            handleDesktopKeys = (e) => {
                if (isMobileDevice) return;
                if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                    e.preventDefault();
                    saveTaskFromModal();
                }
            };
            taskForm.addEventListener('keydown', handleDesktopKeys);

            updateHeader();
            document.getElementById('add-task-btn').addEventListener('click', () => showModal());
            document.getElementById('close-archive-btn').addEventListener('click', () => history.back());
            document.getElementById('hibernate-btn').addEventListener('click', toggleHibernation);
            taskForm.addEventListener('submit', (e) => {
                e.preventDefault();
                saveTaskFromModal();
            });
            document.getElementById('attachment-modal-save-btn').addEventListener('click', saveAttachment);
            document.getElementById('attachment-modal-container').addEventListener('click', (e) => { if(e.target === e.currentTarget) {
                hideAttachmentModal();
                showStickerOrb();
            } });
            document.getElementById('attachment-modal-container').addEventListener('click', (e) => { if(e.target === e.currentTarget) hideAttachmentModal(); });

            confirmationModal.addEventListener('click', (e) => { if (e.target === e.currentTarget) hideConfirmationModal(); });
            document.getElementById('confirmation-modal-cancel-btn').addEventListener('click', hideConfirmationModal);
            document.getElementById('confirmation-modal-confirm-btn').addEventListener('click', () => {
                if(typeof onConfirmCallback === 'function') {
                    onConfirmCallback();
                }
                hideConfirmationModal();
            });
            
            const attachmentUrlInput = document.getElementById('attachment-url-input');
            attachmentUrlInput.addEventListener('input', () => {
                autoGrow(attachmentUrlInput);
                const url = attachmentUrlInput.value;
                const iconContainer = document.getElementById('attachment-modal-icon');
                const paperclipSVG = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>`;
                const figmaIconHTML = `<img src="figma.png" alt="Figma Icon" width="28" height="28" style="vertical-align: middle;">`;
                const jiraIconHTML = `<img src="jira.png" alt="Jira Icon" width="28" height="28" style="vertical-align: middle;">`;

                if (url.includes('figma.com')) {
                    iconContainer.innerHTML = figmaIconHTML;
                } else if (url.includes('atlassian.net')) {
                    iconContainer.innerHTML = jiraIconHTML;
                } else if (url.trim() !== '') {
                    iconContainer.innerHTML = 'üìÑ';
                } else {
                    iconContainer.innerHTML = paperclipSVG;
                }
            });

            modalContainer.addEventListener('click', (e) => {
                if (modalJustOpened) return;
                if (e.target === modalContainer) {
                    if (isKeyboardVisible && document.activeElement) {
                        document.activeElement.blur();
                    } else {
                        history.back();
                    }
                }
            });
            taskTitleInput.addEventListener('input', () => autoGrow(taskTitleInput));
            taskTitleInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    const todayStr = toYYYYMMDD(new Date());
                    const dailyEntriesWrapper = document.getElementById('daily-entries-wrapper');
                    const todayTextarea = dailyEntriesWrapper.querySelector(`.daily-entry-textarea[data-date="${todayStr}"]`);
                    if (todayTextarea) {
                        todayTextarea.focus();
                    } else {
                        taskForm.requestSubmit();
                    }
                }
            });
            peopleChipContainer.addEventListener('click', e => { if (e.target.classList.contains('chip')) { e.target.classList.toggle('selected'); } else if (e.target.id === 'add-people-tag-btn') { handleAddTag(peopleChipContainer, 'people'); } });
            moduleChipContainer.addEventListener('click', e => { if (e.target.classList.contains('chip')) { e.target.classList.toggle('selected'); } else if (e.target.id === 'add-modules-tag-btn') { handleAddTag(moduleChipContainer, 'modules'); } });
            taskListView.addEventListener('mousedown', (e) => onDragStart(e.clientX, e.clientY, e.target));
            document.addEventListener('mousemove', (e) => onDragMove(e.clientX, e.clientY));
            document.addEventListener('mouseup', onDragEnd);
            taskListView.addEventListener('touchstart', (e) => onDragStart(e.touches[0].clientX, e.touches[0].clientY, e.target), { passive: true });
            document.addEventListener('touchmove', (e) => onDragMove(e.touches[0].clientX, e.touches[0].clientY));
            document.addEventListener('touchend', onDragEnd);
            taskListView.addEventListener('dblclick', (e) => { if (e.target === taskListView) showModal(); });
            document.addEventListener('mousemove', (e) => { handleAttachmentMove(e.clientX, e.clientY); });
            document.addEventListener('mouseup', (e) => { handleAttachmentDrop(); });
            document.addEventListener('touchmove', (e) => { if (!isDraggingAttachment) return; e.preventDefault(); const touch = e.touches[0]; handleAttachmentMove(touch.clientX, touch.clientY); }, { passive: false });
            document.addEventListener('touchend', (e) => { handleAttachmentDrop(); });

            let calendarTouchStartX = 0, calendarTouchStartY = 0, calendarDragCurrentX = 0, calendarDragCurrentY = 0, isCalendarDragging = false, calendarDragDirectionLock = null;

            const handleCalendarDragStart = (clientX, clientY) => {
                if (isCalendarDragging) return;
                calendarSlider.style.transition = 'none';
                isCalendarDragging = true;
                calendarTouchStartX = clientX;
                calendarTouchStartY = clientY;
                calendarDragCurrentX = clientX;
                calendarDragCurrentY = clientY;
                calendarDragDirectionLock = null;
                calendarView.style.cursor = 'grabbing';
            };
            const handleCalendarDragMove = (clientX, clientY) => {
                if (!isCalendarDragging) return;
                calendarDragCurrentX = clientX;
                calendarDragCurrentY = clientY;
                const diffX = calendarDragCurrentX - calendarTouchStartX;
                const diffY = calendarDragCurrentY - calendarTouchStartY;

                if (!calendarDragDirectionLock && (Math.abs(diffX) > 5 || Math.abs(diffY) > 5)) {
                    if (Math.abs(diffY) > Math.abs(diffX)) {
                        calendarDragDirectionLock = 'vertical';
                    } else {
                        calendarDragDirectionLock = 'horizontal';
                    }
                }

                if (calendarDragDirectionLock === 'horizontal') {
                    calendarSlider.style.transform = `translateX(calc(-33.3333% + ${diffX}px))`;
                }
            };
            const handleCalendarDragEnd = () => {
                if (!isCalendarDragging) return;
                
                const wasHorizontalDrag = calendarDragDirectionLock === 'horizontal';
                isCalendarDragging = false;
                calendarDragDirectionLock = null;
                calendarView.style.cursor = 'default';
                
                const diffX = calendarDragCurrentX - calendarTouchStartX;
                const threshold = calendarView.offsetWidth / 4;
                calendarSlider.style.transition = 'transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1)';

                if (wasHorizontalDrag && Math.abs(diffX) > threshold) {
                    if (diffX < 0) {
                        calendarSlider.style.transform = 'translateX(-66.6666%)';
                        calendarDate.setMonth(calendarDate.getMonth() + 1);
                    } else {
                        calendarSlider.style.transform = 'translateX(0%)';
                        calendarDate.setMonth(calendarDate.getMonth() - 1);
                    }
                    updateHeader();
                    calendarSlider.addEventListener('transitionend', postSlideReset, { once: true });
                } else {
                    calendarSlider.style.transform = 'translateX(-33.3333%)';
                }
            };

            calendarView.addEventListener('touchstart', e => { if (e.target.closest('button') || e.target.closest('.task-bar') || e.target.classList.contains('day-number')) return; handleCalendarDragStart(e.touches[0].clientX, e.touches[0].clientY); }, { passive: true });
            calendarView.addEventListener('touchmove', e => { if (!isCalendarDragging) return; handleCalendarDragMove(e.touches[0].clientX, e.touches[0].clientY); }, { passive: true });
            calendarView.addEventListener('touchend', e => { if (!isCalendarDragging) return; handleCalendarDragEnd(); });
            calendarView.addEventListener('mousedown', e => { if (e.target.closest('button') || e.target.closest('.task-bar') || e.target.classList.contains('day-number')) return; handleCalendarDragStart(e.clientX, e.clientY); });
            calendarView.addEventListener('mousemove', e => { if (!isCalendarDragging) return; handleCalendarDragMove(e.clientX, e.clientY); });
            calendarView.addEventListener('mouseup', e => { if (!isCalendarDragging) return; handleCalendarDragEnd(); });
            calendarView.addEventListener('mouseleave', e => { if (!isCalendarDragging) return; handleCalendarDragEnd(); });

            document.getElementById('archive-filter-bar').addEventListener('click', (e) => {
                const chip = e.target.closest('.filter-chip');
                if (!chip) return;
                const tag = chip.dataset.tag;
                activeFilterTag = (activeFilterTag === tag) ? null : tag;
                renderArchivedTasks(document.getElementById('archive-content'), false);
            });

            document.getElementById('filter-bar').addEventListener('click', (e) => {
                const chip = e.target.closest('.filter-chip');
                if (!chip) return;
                const tag = chip.dataset.tag;
 
                if (tag === 'archived') {
                    activeFilterTag = null; // Deselect any active filter
                    const archiveView = document.getElementById('archive-view');
                    if (!archiveView.classList.contains('show')) {
                        showArchiveView();
                        archiveView.addEventListener('transitionend', () => {
                            if (currentView === 'calendar') {
                                renderCalendar(); // Re-render calendar view in background
                            } else {
                                renderTasks(); // Re-render list view in background
                            }
                        }, { once: true });
                    }
                    return;
                }
 
                const archiveView = document.getElementById('archive-view');
                if (archiveView.classList.contains('show')) { // If archive is open, close it before applying filter
                    history.back(); // This will trigger hideArchiveView
                }
                
                activeFilterTag = (activeFilterTag === tag) ? null : tag;

                if (currentView === 'calendar') {
                    renderCalendar();
                } else {
                    renderTasks(true);
                }
            });

            viewToggle.addEventListener('click', toggleView);

            if (useGoogleSheets) {
                toastAuthorizeBtn.onclick = handleAuthClick;
            } else {
                document.getElementById('auth-container').style.display = 'none';
                document.getElementById('toast-container').style.display = 'none';
                loadData();
            }

            initializeAttachmentOrb();
            initializeArchiveAttachmentOrb();
        };

        document.addEventListener('DOMContentLoaded', initializeApp);
    })();
    </script>
</body>
</html>
